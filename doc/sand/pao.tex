\if 0
%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{0}



\title{PAO}
\date{Apr 13, 2021}
\release{1.0}
\author{PAO Developers}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\subsection{Introduction}

PAO is a Python\sphinxhyphen{}based package for Adversarial Optimization.  The goal of
this package is to provide a general modeling and analysis capability for
bilevel, trilevel and other multilevel optimization forms that express
adversarial dynamics.  PAO integrates two different modeling abstractions:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxstylestrong{Algebraic models} extend the modeling concepts in the
\sphinxhref{https://github.com/Pyomo/pyomo}{Pyomo} algebraic modeling language
to express problems with an intuitive algebraic syntax.  Thus, we
expect that this modeling abstraction will commonly be used by PAO
end\sphinxhyphen{}users.

\item {} 
\sphinxstylestrong{Compact models} express objective and constraints in a manner
that is typically used to express the mathematical form of these
problems (e.g. using vector and matrix data types).  PAO defines
custom \sphinxstyleemphasis{Multilevel Problem Representations} (MPRs) that simplify the
implementation of solvers for bilevel, trilevel and other multilevel
optimization problems.

\end{enumerate}

\fi

\section{Installation}
\label{\detokenize{installation:installation}}\label{\detokenize{installation::doc}}
PAO currently supports the following versions of Python:
\begin{itemize}
\item {} 
CPython: 3.7, 3.8, 3.9

\end{itemize}


\subsection{Using PIP}
\label{\detokenize{installation:using-pip}}
The standard utility for installing Python packages is \sphinxstylestrong{pip}.
You can install the latest release of PAO by executing the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip install pao
\end{sphinxVerbatim}

You can also use \sphinxstylestrong{pip} to install from the PAO software repository.
For example, the master branch can be installed as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python \PYGZhy{}m pip install https://github.com/or\PYGZhy{}fusion/pao.git
\end{sphinxVerbatim}


\subsection{Using CONDA}
\label{\detokenize{installation:using-conda}}
The \sphinxstylestrong{conda} utility can be used to install the latest release of PAO
using the \sphinxcode{\sphinxupquote{conda\sphinxhyphen{}forge}} channel:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
conda install \PYGZhy{}c conda\PYGZhy{}forge pao
\end{sphinxVerbatim}


\subsection{Using GIT}
\label{\detokenize{installation:using-git}}
PAO can be installed by cloning the PAO software repostory and
then directly installing the software.  For example, the master
branch can be installed as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git clone https://github.com/or\PYGZhy{}fusion/pao.git
cd pao
python setup.py develop
\end{sphinxVerbatim}


\subsection{Conditional Dependencies}
\label{\detokenize{installation:conditional-dependencies}}
Both \sphinxstylestrong{conda} and \sphinxstylestrong{pip} can be used to install the third\sphinxhyphen{}party packages
that are needed to model problems with PAO.  We recommend \sphinxstylestrong{conda}
because it has better support for optimization solver packages.

PAO intrinsically depends on \sphinxhref{https://github.com/Pyomo/pyomo}{Pyomo},
both for the representation of algebraic problems but also for
interfaces to numerical optimizers used by PAO solvers.  \sphinxhref{https://github.com/Pyomo/pyomo}{Pyomo} is installed with PAO, but the Pyomo
website \sphinxcite{pyomoweb} and GitHub site \sphinxcite{pyomogithub} provide additional
resources for installing Pyomo and related software.

PAO and \sphinxhref{https://github.com/Pyomo/pyomo}{Pyomo} have conditional
dependencies on a variety of third\sphinxhyphen{}party packages, including Python
packages like scipy, numpy and optimization solvers.  Optimization solvers
are particularly important, and a commercial optimizer may be needed to
analyze complex, real\sphinxhyphen{}world applications.

The following optimizers are used to test the PAO solvers:
\begin{itemize}
\item {} 
\sphinxhref{https://www.gnu.org/software/glpk/}{glpk} \sphinxhyphen{} An open\sphinxhyphen{}source mixed\sphinxhyphen{}integer linear programming solver

\item {} 
\sphinxhref{https://github.com/coin-or/Cbc}{cbc} \sphinxhyphen{} An open\sphinxhyphen{}source mixed\sphinxhyphen{}integer linear programming solver

\item {} 
\sphinxhref{https://github.com/coin-or/Ipopt}{ipopt} \sphinxhyphen{} An open\sphinxhyphen{}source interior point optimizer for continuous problems

\end{itemize}

Additionally, PAO can interface with optimization solvers at \sphinxhref{https://neos-server.org/neos/}{NEOS}.


\section{Overview}
\label{\detokenize{overview:overview}}\label{\detokenize{overview::doc}}
Many planning situations involve the analysis of a hierarchy of
decision\sphinxhyphen{}makers with competing objectives.  For example, policy decisions
are made at different levels of a government, each of which has a
different objective and decision space.  Similarly, robust planning
against adversaries is often modeled with a 2\sphinxhyphen{}level hierarchy, where
the defensive planner makes decisions that account for adversarial
response.  Multilevel optimization techniques partition control over
decision variables amongst the levels.  Decisions at each level of
the hierarchy may be constrained by decisions at other levels, and the
objectives for each level may account for decisions made at other levels.
The PAO library is designed to express this structure in a manner that is
intuitive to users, and which facilitates the application of appropriate
optimization solvers.  In particular, PAO extends the modeling concepts
in the \sphinxhref{https://github.com/Pyomo/pyomo}{Pyomo} algebraic modeling
language to express problems with an intuitive algebraic syntax.

However, data structures used to represent algebraic models are often
poorly suited for complex numerical algorithms.  Consequently, PAO
supports \sphinxstyleemphasis{distinct} representations for algebraic models (using \sphinxhref{https://github.com/Pyomo/pyomo}{Pyomo}) and compact problem representations
that express objective and constraints using vector and matrix data types.
Currently, PAO includes several \sphinxstyleemphasis{Multilevel Problem Representations}
(MPRs) that represent multilevel optimization problems with an explicit,
compact representation that simplifies the implementation of solvers
for bilevel, trilevel and other multilevel optimization problems.

For example, PAO includes a compact representation for linear bilevel
problems, \sphinxcode{\sphinxupquote{LinearMultilevelProblem}}.  Several solvers have been
developed for problems expressed as a \sphinxcode{\sphinxupquote{LinearMultilevelProblem}},
including the big\sphinxhyphen{}M method proposed by Fortuny\sphinxhyphen{}Amat and McCarl
\sphinxcite{fortunymccarl}.  PAO can similarly express linear bilevel problems in
Pyomo using a \sphinxcode{\sphinxupquote{Submodel}} component, which was previously introduced in
the \sphinxstylestrong{pyomo.bilevel} package \sphinxcite{pyomobookii}.  Further, these Pyomo models
can be automatically converted to the compact \sphinxcode{\sphinxupquote{LinearMultilevelProblem}}
representation and optimized with solvers tailored for that representation.

The use of independent problem representations in this manner has
several implications for PAO.  First, this design facilitates the
development of solvers for algebraic modeling languages like Pyomo
that are intrinsically more robust.  Compact representations like
\sphinxcode{\sphinxupquote{LinearMultilevelProblem}} enable the development of solvers using
natural operations (e.g. matrix\sphinxhyphen{}vector multiplication).  Thus, we expect
these solvers to be more robust and easier to maintain when compared to
solvers developed using Pyomo data structures (e.g. expression trees).
Additionally, the conversion of a Pyomo representation to a compact
representation provides a context for verifying that the Pyomo model
represents the intended problem form.

Second, this design facilitates the development of different problem
representations that may or may not be inter\sphinxhyphen{}operable.  Although PAO
is derived from initial efforts with \sphinxstylestrong{pyomo.bilevel}, it has evolved
from an extension of Pyomo’s modeling capability to be a library that
is synergistic with Pyomo but not strictly dependent on it.

The following sections provide detailed descriptions of these
representations that are illustrated with increasingly complex examples,
including
\begin{itemize}
\item {} 
bilevel

\item {} 
bilevel with multiple lower\sphinxhyphen{}levels

\item {} 
trilevel

\end{itemize}

Additionally, the following sections describe the setup of linear and
quadratic problems, and the transformations that can be applied to them
in PAO.

\begin{sphinxadmonition}{note}{Note:}
We do not restrict the description of PAO representations to
models that PAO can solve. Rather, a goal of this documentation
to illustrate the breadth of the adversarial optimization problems
that can be expressed with PAO, thereby motivating the development
of new solvers for new classes of problems.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Although the modeling abstractions in PAO are suitable for both
pessimistic and optimistic multilevel optimization formulations,
PAO currently assumes that all problems are expressed and solved
in an an optimistic form.  Thus, when there multiple solutions in
lower\sphinxhyphen{}level problems, the choice of the solution is determined by
the follower not the leader.  This convention reflects the fact that
solution techniques for pessimistic forms are not well\sphinxhyphen{}developed.
\end{sphinxadmonition}


\section{Simple Examples}
\label{\detokenize{examples:simple-examples}}\label{\detokenize{examples::doc}}
We illustrate the PAO algebraic and compact representations with a series
of simple examples.  Consider the following bilevel problem introduced
by Bard \sphinxcite{bard98} (example 5.1.1):
 \begin{equation*}
 \begin{array}{lll}
 \min_{x \geq 0} & x - 4 y & \\
 \textrm{s.t.} & \min_{y \geq 0} & y\\
 & \textrm{s.t.} & -x -y \leq -3\\
 & & -2 x + y \leq 0\\
 & & 2 x + y \leq 12\\
 & & 3 x - 2 y \leq 4
 \end{array}
 \end{equation*}
This problem has has linear upper\sphinxhyphen{} and lower\sphinxhyphen{}level problems with different
objectives in each level.  Thus, this problem can be represented in
PAO using a Pyomo model representation or the \sphinxcode{\sphinxupquote{LinearMultilevelProblem}}
representation.


\subsection{Using Pyomo}
\label{\detokenize{examples:using-pyomo}}
The following python script defines a bilevel problem in Pyomo:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{pyomo}\PYG{n+nn}{.}\PYG{n+nn}{environ} \PYG{k}{as} \PYG{n+nn}{pe}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{pao}\PYG{n+nn}{.}\PYG{n+nn}{pyomo} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+go}{\PYGZsh{} Create a model object}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{ConcreteModel}\PYG{p}{(}\PYG{p}{)}

\PYG{g+go}{\PYGZsh{} Define decision variables}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Var}\PYG{p}{(}\PYG{n}{bounds}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{y} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Var}\PYG{p}{(}\PYG{n}{bounds}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{)}

\PYG{g+go}{\PYGZsh{} Define the upper\PYGZhy{}level objective}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{o} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Objective}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{y}\PYG{p}{)}

\PYG{g+go}{\PYGZsh{} Create a SubModel component to declare a lower\PYGZhy{}level problem}
\PYG{g+go}{\PYGZsh{} The variable M.x is fixed in this lower\PYGZhy{}level problem}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L} \PYG{o}{=} \PYG{n}{SubModel}\PYG{p}{(}\PYG{n}{fixed}\PYG{o}{=}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{p}{)}

\PYG{g+go}{\PYGZsh{} Define the lower\PYGZhy{}level objective}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{o} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Objective}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}\PYG{n}{M}\PYG{o}{.}\PYG{n}{y}\PYG{p}{)}

\PYG{g+go}{\PYGZsh{} Define lower\PYGZhy{}level constraints}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{c1} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}   \PYG{o}{\PYGZhy{}}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{\PYGZhy{}}   \PYG{n}{M}\PYG{o}{.}\PYG{n}{y} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{c2} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+}   \PYG{n}{M}\PYG{o}{.}\PYG{n}{y} \PYG{o}{\PYGZlt{}}\PYG{o}{=}  \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{c3} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}  \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+}   \PYG{n}{M}\PYG{o}{.}\PYG{n}{y} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{12}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{c4} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}  \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{y} \PYG{o}{\PYGZlt{}}\PYG{o}{=}  \PYG{l+m+mi}{4}\PYG{p}{)}

\PYG{g+go}{\PYGZsh{} Create a solver and apply it}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pao.pyomo.FA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{solver}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{results} \PYG{o}{=} \PYG{n}{solver}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}

\PYG{g+go}{\PYGZsh{} The final solution is loaded into the model}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}
\PYG{g+go}{4.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{M}\PYG{o}{.}\PYG{n}{y}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}
\PYG{g+go}{4.0}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{SubModel}} component defines a Pyomo block object within which the
lower\sphinxhyphen{}level problem is declared.  The \sphinxcode{\sphinxupquote{fixed}} option is used to specify
the upper\sphinxhyphen{}level variables whose value is fixed in the lower\sphinxhyphen{}level problem.

The \sphinxcode{\sphinxupquote{pao.pyomo.FA}} uses the method for solving linear bilevel
programs with big\sphinxhyphen{}M relaxations described by Fortuny\sphinxhyphen{}Amat and McCarl
\sphinxcite{fortunymccarl}.  In this example, the default big\sphinxhyphen{}M value is used, but
in general a user may need to explore suitable values for their problem.
By default, the final values of the upper\sphinxhyphen{} and lower\sphinxhyphen{}level variables
are loaded back into the Pyomo model.  The \sphinxcode{\sphinxupquote{results}} object contains
information about the problem, the solver and the solver status.


\subsection{Using LinearMultilevelProblem}
\label{\detokenize{examples:using-linearmultilevelproblem}}
Bilevel linear problems can also be represented using the
\sphinxcode{\sphinxupquote{LinearMultilevelProblem}} class.  This class provides a simple mechanism
for organizing data for variables, objectives and linear constraints.  The following
examples illustrate the use of \sphinxcode{\sphinxupquote{LinearMultilevelProblem}} for Bard’s example 5.1.1 described
above, but this representation can naturally be used to express multi\sphinxhyphen{}level problems as well
as problems with multiple lower\sphinxhyphen{}levels.


\paragraph{Using Numpy and Scipy Data}
\label{\detokenize{examples:using-numpy-and-scipy-data}}
The following python script defines a bilevel problem using \sphinxcode{\sphinxupquote{LinearMultilevelProblem}} with
numpy and scipy data:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{sparse} \PYG{k+kn}{import} \PYG{n}{coo\PYGZus{}matrix}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{pao}\PYG{n+nn}{.}\PYG{n+nn}{mpr} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+go}{\PYGZsh{} Create a model object}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M} \PYG{o}{=} \PYG{n}{LinearMultilevelProblem}\PYG{p}{(}\PYG{p}{)}

\PYG{g+go}{\PYGZsh{} Declare the upper\PYGZhy{} and lower\PYGZhy{}levels, including the number of decision\PYGZhy{}variables}
\PYG{g+go}{\PYGZsh{}  nxR=1 means there will be 1 real\PYGZhy{}valued decision variable}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U} \PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{add\PYGZus{}upper}\PYG{p}{(}\PYG{n}{nxR}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L} \PYG{o}{=} \PYG{n}{U}\PYG{o}{.}\PYG{n}{add\PYGZus{}lower}\PYG{p}{(}\PYG{n}{nxR}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{g+go}{\PYGZsh{} Declare the bounds on the decision variables}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{g+go}{\PYGZsh{} Declare the upper\PYGZhy{}level objective}
\PYG{g+go}{\PYGZsh{}   U.c[X] is the array of coefficients in the objective for variables in level X}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{U}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{L}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}

\PYG{g+go}{\PYGZsh{} Declare the lower\PYGZhy{}level objective, which has no upper\PYGZhy{}level decision\PYGZhy{}variables}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{L}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{g+go}{\PYGZsh{} Declare the lower\PYGZhy{}level constraints}
\PYG{g+go}{\PYGZsh{}   L.A[X] is the matrix coefficients in the constraints for variables in level X}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{A}\PYG{p}{[}\PYG{n}{U}\PYG{p}{]} \PYG{o}{=} \PYG{n}{coo\PYGZus{}matrix}\PYG{p}{(}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} Coefficients}
\PYG{g+gp}{... }                   \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}     \PYG{c+c1}{\PYGZsh{} Row indices of matrix entries}
\PYG{g+gp}{... }                    \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} Column indices of matrix entries}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{A}\PYG{p}{[}\PYG{n}{L}\PYG{p}{]} \PYG{o}{=} \PYG{n}{coo\PYGZus{}matrix}\PYG{p}{(}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }                   \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }                    \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{g+go}{\PYGZsh{} Declare the constraint right\PYGZhy{}hand\PYGZhy{}side}
\PYG{g+go}{\PYGZsh{}   By default, constraints are inequalities, so these are upper\PYGZhy{}bounds}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}

\PYG{g+go}{\PYGZsh{} Create a solver and apply it}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pao.mpr.FA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{solver}\PYG{p}{:}
\PYG{g+gp}{... }   \PYG{n}{results} \PYG{o}{=} \PYG{n}{solver}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}

\PYG{g+go}{\PYGZsh{} The final solution is loaded into the model}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{U}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{values}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{4.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{L}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{values}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{4.0}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{U}} and \sphinxcode{\sphinxupquote{L}} objects represent the upper\sphinxhyphen{} and lower\sphinxhyphen{}level
respectively.  When declaring these objects, the user specifies the number
of real, integer and binary variables.  The remaining declarations assume
that these variables are used in that order.  Thus, there is a single
declaration for the objective coefficients, \sphinxcode{\sphinxupquote{c}}, which is an array
with values for each of the declared variables.  However, the upper\sphinxhyphen{}
and lower\sphinxhyphen{}level objective coefficients are separately declared for
the upper\sphinxhyphen{} and lower\sphinxhyphen{}level variables by indexing \sphinxcode{\sphinxupquote{c}} with \sphinxcode{\sphinxupquote{U}} and
\sphinxcode{\sphinxupquote{L}} respectively.  This example includes declarations for the upper\sphinxhyphen{}
and lower\sphinxhyphen{}level variable bounds and objective coefficients.  There are no
upper\sphinxhyphen{}level constraints, so only the lower\sphinxhyphen{}level constriants are declared.

Note that the syntax for specifying solvers is analogous to that used
with Pyomo models.  The same solver options are available.  The principle
difference is the specification of the solver name that indicates the
expected type of the model that will be solved.


\paragraph{Using Python Lists and Dictionaries}
\label{\detokenize{examples:using-python-lists-and-dictionaries}}
Although the constraint matrices are dense in this example, the
\sphinxcode{\sphinxupquote{coo\_matrix}} is used to illustrate the general support for sparse data.
The \sphinxcode{\sphinxupquote{LinearMultilevelProblem}} class also supports a simpler syntax
where dense arrays can be specified and Python lists and sparse matrices
can be specified with Python tuple and dictionary objects:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{pao}\PYG{n+nn}{.}\PYG{n+nn}{mpr} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M} \PYG{o}{=} \PYG{n}{LinearMultilevelProblem}\PYG{p}{(}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U} \PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{add\PYGZus{}upper}\PYG{p}{(}\PYG{n}{nxR}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L} \PYG{o}{=} \PYG{n}{U}\PYG{o}{.}\PYG{n}{add\PYGZus{}lower}\PYG{p}{(}\PYG{n}{nxR}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{U}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{L}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{L}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{A}\PYG{p}{[}\PYG{n}{U}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{A}\PYG{p}{[}\PYG{n}{L}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pao.mpr.FA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{solver}\PYG{p}{:}
\PYG{g+gp}{... }   \PYG{n}{results} \PYG{o}{=} \PYG{n}{solver}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{U}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{values}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{4.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{L}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{values}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{4.0}
\end{sphinxVerbatim}

When specifying a sparse matrix, a tuple is provided (e.g. for
\sphinxcode{\sphinxupquote{L.A{[}U{]}}}).  The first element is a 2\sphinxhyphen{}tuple that defines the shape
of the matrix, and the second element is a dictionary that defines the
non\sphinxhyphen{}zero values in the sparse matrix.

Similarly, a list\sphinxhyphen{}of\sphinxhyphen{}lists syntax can be used to specify dense matrices:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{pao}\PYG{n+nn}{.}\PYG{n+nn}{mpr} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M} \PYG{o}{=} \PYG{n}{LinearMultilevelProblem}\PYG{p}{(}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U} \PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{add\PYGZus{}upper}\PYG{p}{(}\PYG{n}{nxR}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L} \PYG{o}{=} \PYG{n}{U}\PYG{o}{.}\PYG{n}{add\PYGZus{}lower}\PYG{p}{(}\PYG{n}{nxR}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{U}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{L}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{L}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{A}\PYG{p}{[}\PYG{n}{U}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{A}\PYG{p}{[}\PYG{n}{L}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pao.mpr.FA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{solver}\PYG{p}{:}
\PYG{g+gp}{... }   \PYG{n}{results} \PYG{o}{=} \PYG{n}{solver}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{U}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{values}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{4.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{L}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{values}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{4.0}
\end{sphinxVerbatim}

When native Python data values are used to initialize a
\sphinxcode{\sphinxupquote{LinearMultilevelProblem}}, they are converted into numpy and scipy
data types.  This facilitates the use of \sphinxcode{\sphinxupquote{LinearMultilevelProblem}}
objects for defining numerical solvers using a consistent, convenient
API for numerical operations (e.g. matrix\sphinxhyphen{}vector multiplication).


\section{Pyomo Models}
\label{\detokenize{representations/pyomo:pyomo-models}}\label{\detokenize{representations/pyomo::doc}}
PAO can be used to express linear and quadratic problems in \sphinxhref{https://github.com/Pyomo/pyomo}{Pyomo} using a {\hyperref[\detokenize{reference/pyomo:pao.pyomo.components.SubModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SubModel}}}}}
component, which was previously introduced in the \sphinxstylestrong{pyomo.bilevel}
package \sphinxcite{pyomobookii}.  \sphinxhref{https://github.com/Pyomo/pyomo}{Pyomo}
represents optimization models using an model objects that are
annotated with modeling component objects.  Thus, {\hyperref[\detokenize{reference/pyomo:pao.pyomo.components.SubModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SubModel}}}}}
component is a simple extension of the modeling concepts in \sphinxhref{https://github.com/Pyomo/pyomo}{Pyomo}.

\begin{sphinxadmonition}{hint}{Hint:}
Advanced Pyomo users will realize that the PAO {\hyperref[\detokenize{reference/pyomo:pao.pyomo.components.SubModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SubModel}}}}} component
is a special case of the Pyomo \sphinxcode{\sphinxupquote{Block}} component, which is used to
structure the expression of Pyomo models.
\end{sphinxadmonition}

A {\hyperref[\detokenize{reference/pyomo:pao.pyomo.components.SubModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SubModel}}}}} component creates a context for expressing the
objective and constraints in a lower\sphinxhyphen{}level model.  Pyomo models can
include nested and parallel {\hyperref[\detokenize{reference/pyomo:pao.pyomo.components.SubModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SubModel}}}}} components to express
complex multilevel problems.


\subsection{Bilevel Examples}
\label{\detokenize{representations/pyomo:bilevel-examples}}
Consider the following bilevel problem:
\label{equation:sand:eq-pao1} \begin{equation*}
 \textbf{Model PAO1}
 \begin{array}{ll}
 \min_{x\in[2,6],y} & x + 3 z \\
 \textrm{s.t.} & x + y = 10\\
 & \begin{array}{lll}
   \max_{z \geq 0} & z &\\
   \textrm{s.t.} & x+z &\leq 8\\
   & x + 4 z &\geq 8\\
   & x + 2 z &\leq 13
   \end{array}
 \end{array}
 \end{equation*}
This problem has has linear upper\sphinxhyphen{} and lower\sphinxhyphen{}level problems with different
objectives in each level.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{ConcreteModel}\PYG{p}{(}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Var}\PYG{p}{(}\PYG{n}{bounds}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{y} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Var}\PYG{p}{(}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{pyomo}\PYG{o}{.}\PYG{n}{SubModel}\PYG{p}{(}\PYG{n}{fixed}\PYG{o}{=}\PYG{p}{[}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,}\PYG{n}{M}\PYG{o}{.}\PYG{n}{y}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{z} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Var}\PYG{p}{(}\PYG{n}{bounds}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{o} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Objective}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{z}\PYG{p}{,} \PYG{n}{sense}\PYG{o}{=}\PYG{n}{pe}\PYG{o}{.}\PYG{n}{minimize}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{c} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+} \PYG{n}{M}\PYG{o}{.}\PYG{n}{y} \PYG{o}{==} \PYG{l+m+mi}{10}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{o} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Objective}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{z}\PYG{p}{,} \PYG{n}{sense}\PYG{o}{=}\PYG{n}{pe}\PYG{o}{.}\PYG{n}{maximize}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{c1} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+} \PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{z} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{c2} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{z} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{c3} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{z} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{13}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pao.pyomo.FA}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{results} \PYG{o}{=} \PYG{n}{opt}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{n}{M}\PYG{o}{.}\PYG{n}{y}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{z}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}
\PYG{g+go}{6.0 4.0 2.0}
\end{sphinxVerbatim}

This example illustrates the flexibility of Pyomo representations in PAO:
\begin{itemize}
\item {} 
Each level can express different objectives with different senses

\item {} 
Variables can be bounded or unbounded

\item {} 
Equality and inequality constraints can be expressed

\end{itemize}

The {\hyperref[\detokenize{reference/pyomo:pao.pyomo.components.SubModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SubModel}}}}} component is used to define a logically separate
optimization model that includes variables that are dynamically fixed
by upper\sphinxhyphen{}level problems.  All of the Pyomo objective and constraint
declarations contained in the {\hyperref[\detokenize{reference/pyomo:pao.pyomo.components.SubModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SubModel}}}}} declaration are included
in the sub\sphinxhyphen{}problem that it defines, even if they are nested in Pyomo
\sphinxcode{\sphinxupquote{Block}} components.  The {\hyperref[\detokenize{reference/pyomo:pao.pyomo.components.SubModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SubModel}}}}} component also declares
which variables are fixed in a lower\sphinxhyphen{}level problem.  The value of the
\sphinxtitleref{fixed} argument is a Pyomo variable or a list of variables.  For example,
the following model expresses the upper\sphinxhyphen{}level variables with a single
variable, \sphinxtitleref{M.x}, which is fixed in the {\hyperref[\detokenize{reference/pyomo:pao.pyomo.components.SubModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SubModel}}}}} declaration:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{ConcreteModel}\PYG{p}{(}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Var}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{setlb}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{setub}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{pyomo}\PYG{o}{.}\PYG{n}{SubModel}\PYG{p}{(}\PYG{n}{fixed}\PYG{o}{=}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{z} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Var}\PYG{p}{(}\PYG{n}{bounds}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{o} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Objective}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{z}\PYG{p}{,} \PYG{n}{sense}\PYG{o}{=}\PYG{n}{pe}\PYG{o}{.}\PYG{n}{minimize}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{c} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{10}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{o} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Objective}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{z}\PYG{p}{,} \PYG{n}{sense}\PYG{o}{=}\PYG{n}{pe}\PYG{o}{.}\PYG{n}{maximize}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{c1} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{z} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{c2} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{z} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{c3} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{z} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{13}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pao.pyomo.FA}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{results} \PYG{o}{=} \PYG{n}{opt}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{z}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}
\PYG{g+go}{6.0 4.0 2.0}
\end{sphinxVerbatim}

Although a lower\sphinxhyphen{}level problem is logically a separate optimization model,
you cannot use a {\hyperref[\detokenize{reference/pyomo:pao.pyomo.components.SubModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SubModel}}}}} that is defined with a separate Pyomo
model object.  Pyomo implicitly requires that all variables used in
objective and constraint expressions are attributes of the same Pyomo model.
However, the location of variable declarations in a Pyomo model does \sphinxstyleemphasis{not} denote their
use in upper\sphinxhyphen{} or lower\sphinxhyphen{}level problems.  For example, consider the following
model that re\sphinxhyphen{}expresses the previous problem:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{ConcreteModel}\PYG{p}{(}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Var}\PYG{p}{(}\PYG{n}{bounds}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{y} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Var}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{z} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Var}\PYG{p}{(}\PYG{n}{bounds}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{o} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Objective}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{z}\PYG{p}{,} \PYG{n}{sense}\PYG{o}{=}\PYG{n}{pe}\PYG{o}{.}\PYG{n}{minimize}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{c} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+} \PYG{n}{M}\PYG{o}{.}\PYG{n}{y} \PYG{o}{==} \PYG{l+m+mi}{10}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{pyomo}\PYG{o}{.}\PYG{n}{SubModel}\PYG{p}{(}\PYG{n}{fixed}\PYG{o}{=}\PYG{p}{[}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,}\PYG{n}{M}\PYG{o}{.}\PYG{n}{y}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{o} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Objective}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}\PYG{n}{M}\PYG{o}{.}\PYG{n}{z}\PYG{p}{,} \PYG{n}{sense}\PYG{o}{=}\PYG{n}{pe}\PYG{o}{.}\PYG{n}{maximize}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{c1} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+} \PYG{n}{M}\PYG{o}{.}\PYG{n}{z} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{c2} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{z} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{c3} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{z} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{13}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pao.pyomo.FA}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{results} \PYG{o}{=} \PYG{n}{opt}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{n}{M}\PYG{o}{.}\PYG{n}{y}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{n}{M}\PYG{o}{.}\PYG{n}{z}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}
\PYG{g+go}{6.0 4.0 2.0}
\end{sphinxVerbatim}

Note that \sphinxstyleemphasis{all} of the decision variables are declared outside of the
{\hyperref[\detokenize{reference/pyomo:pao.pyomo.components.SubModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SubModel}}}}} component, even though the variable \sphinxcode{\sphinxupquote{M.z}} is a
lower\sphinxhyphen{}level variable.  The declarations of {\hyperref[\detokenize{reference/pyomo:pao.pyomo.components.SubModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SubModel}}}}} components
defines the mathematical role of all decision variables in a Pyomo model.
As this example illustrates, the specification of a bilevel problem can
be simplified if all variables are expressed at once.

Finally, we observe that PAO’s Pyomo representation only works with a
subset of the many different modeling components that are supported in
\sphinxhref{https://github.com/Pyomo/pyomo}{Pyomo}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Set}} \sphinxhyphen{} Set declarations

\item {} 
\sphinxcode{\sphinxupquote{Param}} \sphinxhyphen{} Parameter declarations

\item {} 
\sphinxcode{\sphinxupquote{Var}} \sphinxhyphen{} Variable declarations

\item {} 
\sphinxcode{\sphinxupquote{Block}} \sphinxhyphen{} Defines a subset of a model

\item {} 
\sphinxcode{\sphinxupquote{Objective}} \sphinxhyphen{} Define a model objective

\item {} 
\sphinxcode{\sphinxupquote{Constraint}} \sphinxhyphen{} Define model constraints

\end{itemize}

Additional Pyomo modeling components will be added to PAO as motivating
applications arise and as suitable solvers become available.


\subsection{Multilevel Examples}
\label{\detokenize{representations/pyomo:multilevel-examples}}
Multilevel problems can be easily expressed with Pyomo using multiple declarations
of {\hyperref[\detokenize{reference/pyomo:pao.pyomo.components.SubModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SubModel}}}}}.


\paragraph{Multiple Lower Levels}
\label{\detokenize{representations/pyomo:multiple-lower-levels}}
Consider the following bilevel problem that
extends the \sphinxstylestrong{PAO1} model to include two equivalent lower\sphinxhyphen{}levels:
\label{equation:sand:eq-pao2} \begin{equation*}
 \textbf{Model PAO2}
 \begin{array}{ll}
 \min_{x\in[2,6],y} & x + 3 z_1 + 3 z_2 \\
 \textrm{s.t.} & x + y = 10\\
 & \begin{array}{lll}
   \max_{z_1 \geq 0} & z_1 &\\
   \textrm{s.t.} & x+z_1 &\leq 8\\
   & x + 4 z_1 &\geq 8\\
   & x + 2 z_1 &\leq 13\\
   \end{array}\\
 & \begin{array}{lll}
   \max_{z_2 \geq 0} & z_2 &\\
   \textrm{s.t.} & y+z_2 &\leq 8\\
   & y + 4 z_2 &\geq 8\\
   & y + 2 z_2 &\leq 13\\
   \end{array}\\
 \end{array}
 \end{equation*}
The \sphinxstylestrong{PAO2} model can be expressed in Pyomo as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{ConcreteModel}\PYG{p}{(}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Var}\PYG{p}{(}\PYG{n}{bounds}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{y} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Var}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{z} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Var}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{bounds}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{o} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Objective}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{z}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{z}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{sense}\PYG{o}{=}\PYG{n}{pe}\PYG{o}{.}\PYG{n}{minimize}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{c} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+} \PYG{n}{M}\PYG{o}{.}\PYG{n}{y} \PYG{o}{==} \PYG{l+m+mi}{10}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L1} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{pyomo}\PYG{o}{.}\PYG{n}{SubModel}\PYG{p}{(}\PYG{n}{fixed}\PYG{o}{=}\PYG{p}{[}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L1}\PYG{o}{.}\PYG{n}{o} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Objective}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}\PYG{n}{M}\PYG{o}{.}\PYG{n}{z}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{sense}\PYG{o}{=}\PYG{n}{pe}\PYG{o}{.}\PYG{n}{maximize}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L1}\PYG{o}{.}\PYG{n}{c1} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+} \PYG{n}{M}\PYG{o}{.}\PYG{n}{z}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L1}\PYG{o}{.}\PYG{n}{c2} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{z}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L1}\PYG{o}{.}\PYG{n}{c3} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{z}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{13}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L2} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{pyomo}\PYG{o}{.}\PYG{n}{SubModel}\PYG{p}{(}\PYG{n}{fixed}\PYG{o}{=}\PYG{p}{[}\PYG{n}{M}\PYG{o}{.}\PYG{n}{y}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L2}\PYG{o}{.}\PYG{n}{o} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Objective}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}\PYG{n}{M}\PYG{o}{.}\PYG{n}{z}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{sense}\PYG{o}{=}\PYG{n}{pe}\PYG{o}{.}\PYG{n}{maximize}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L2}\PYG{o}{.}\PYG{n}{c1} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{y} \PYG{o}{+} \PYG{n}{M}\PYG{o}{.}\PYG{n}{z}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L2}\PYG{o}{.}\PYG{n}{c2} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{y} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{z}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L2}\PYG{o}{.}\PYG{n}{c3} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{y} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{z}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{13}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pao.pyomo.FA}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{results} \PYG{o}{=} \PYG{n}{opt}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{n}{M}\PYG{o}{.}\PYG{n}{y}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{n}{M}\PYG{o}{.}\PYG{n}{z}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{n}{M}\PYG{o}{.}\PYG{n}{z}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}
\PYG{g+go}{2.0 8.0 5.5 0.0}
\end{sphinxVerbatim}


\paragraph{Trilevel Problems}
\label{\detokenize{representations/pyomo:trilevel-problems}}
Trilevel problems can be described with nested declarations of
{\hyperref[\detokenize{reference/pyomo:pao.pyomo.components.SubModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SubModel}}}}} components.  Consider the following trilevel continuous
linear problem described by Anadalingam \sphinxcite{anadalingam}:
\label{equation:sand:eq-anadalingam} \begin{equation*}
 \textbf{Model Anadalingam1988}
 \begin{array}{llll}
 \min_{x_1 \geq 0} & -7 x_1 - 3 x_2 + 4 x_3 \\
 \textrm{s.t.} & \min_{x_2 \geq 0} & -x_2 \\
               & \textrm{s.t.} & \min_{x_3 \in [0,0.5]} & -x_3 \\
               &               & \textrm{s.t.} & x_1 + x_2 + x_3 \leq 3\\
               &               &               & x_1 + x_2 - x_3 \leq 1\\
               &               &               & x_1 + x_2 + x_3 \geq 1\\
               &               &               & -x_1 + x_2 + x_3 \leq 1\\
 \end{array}
 \end{equation*}
This model can be expressed in Pyomo as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{ConcreteModel}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{x1} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Var}\PYG{p}{(}\PYG{n}{bounds}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{x2} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Var}\PYG{p}{(}\PYG{n}{bounds}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{x3} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Var}\PYG{p}{(}\PYG{n}{bounds}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{pyomo}\PYG{o}{.}\PYG{n}{SubModel}\PYG{p}{(}\PYG{n}{fixed}\PYG{o}{=}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x1}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{B} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{pyomo}\PYG{o}{.}\PYG{n}{SubModel}\PYG{p}{(}\PYG{n}{fixed}\PYG{o}{=}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x2}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{o} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Objective}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x2} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x3}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{o} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Objective}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{B}\PYG{o}{.}\PYG{n}{o} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Objective}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x3}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{B}\PYG{o}{.}\PYG{n}{c1} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}   \PYG{n}{M}\PYG{o}{.}\PYG{n}{x1} \PYG{o}{+} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x2} \PYG{o}{+} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x3} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{B}\PYG{o}{.}\PYG{n}{c2} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}   \PYG{n}{M}\PYG{o}{.}\PYG{n}{x1} \PYG{o}{+} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x2} \PYG{o}{\PYGZhy{}} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x3} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{B}\PYG{o}{.}\PYG{n}{c3} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}   \PYG{n}{M}\PYG{o}{.}\PYG{n}{x1} \PYG{o}{+} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x2} \PYG{o}{+} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x3} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{B}\PYG{o}{.}\PYG{n}{c4} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{o}{\PYGZhy{}} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x1} \PYG{o}{+} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x2} \PYG{o}{+} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x3} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
PAO solvers cannot currently solve trilevel problems like this,
but an issue has been submitted to add this functionality.
\end{sphinxadmonition}


\paragraph{Bilinear Problems}
\label{\detokenize{representations/pyomo:bilinear-problems}}
PAO models using Pyomo represent general quadratic problems with quadratic
terms in the objective and constraints at each level.  The special
case where bilinear terms arise with an upper\sphinxhyphen{}level binary variable
multiplied with a lower\sphinxhyphen{}level variable is common in many applications.
For this case, the PAO solvers for Pyomo models include an option to
linearize these bilinear terms.

The following models considers a variation of the \sphinxstylestrong{PAO1} model where
binary variables control the expression of lower\sphinxhyphen{}level constraints:
\label{equation:sand:eq-pao3} \begin{equation*}
 \textbf{Model PAO3}
 \begin{array}{ll}
 \min_{x\in[2,6],y,w_1,w_2} & x + 3 z + 5 w_1\\
 \textrm{s.t.} & x + y = 10\\
 & w_1 + w_2 \geq 1\\
 & w_1,w_2 \in \{0,1\}\\
 & \begin{array}{lll}
   \max_{z \geq 0} & z &\\
   \textrm{s.t.} & x+ w_1 z &\leq 8\\
   & x + 4 z &\geq 8\\
   & x + 2 w_2 z &\leq 13
   \end{array}
 \end{array}
 \end{equation*}
The \sphinxstylestrong{PAO3} model can be expressed in Pyomo as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{ConcreteModel}\PYG{p}{(}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{w} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Var}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{within}\PYG{o}{=}\PYG{n}{pe}\PYG{o}{.}\PYG{n}{Binary}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Var}\PYG{p}{(}\PYG{n}{bounds}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{y} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Var}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{z} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Var}\PYG{p}{(}\PYG{n}{bounds}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{o} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Objective}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{z}\PYG{o}{+}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{w}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{sense}\PYG{o}{=}\PYG{n}{pe}\PYG{o}{.}\PYG{n}{minimize}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{c1} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+} \PYG{n}{M}\PYG{o}{.}\PYG{n}{y} \PYG{o}{==} \PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{c2} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{w}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{n}{M}\PYG{o}{.}\PYG{n}{w}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{pyomo}\PYG{o}{.}\PYG{n}{SubModel}\PYG{p}{(}\PYG{n}{fixed}\PYG{o}{=}\PYG{p}{[}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{p}{,}\PYG{n}{M}\PYG{o}{.}\PYG{n}{y}\PYG{p}{,}\PYG{n}{M}\PYG{o}{.}\PYG{n}{w}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{o} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Objective}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}\PYG{n}{M}\PYG{o}{.}\PYG{n}{z}\PYG{p}{,} \PYG{n}{sense}\PYG{o}{=}\PYG{n}{pe}\PYG{o}{.}\PYG{n}{maximize}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{c1} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+} \PYG{n}{M}\PYG{o}{.}\PYG{n}{w}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{z} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{c2} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{z} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{c3} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{w}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{*}\PYG{n}{M}\PYG{o}{.}\PYG{n}{z} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{13}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pao.pyomo.FA}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{linearize\PYGZus{}bigm}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{results} \PYG{o}{=} \PYG{n}{opt}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{n}{M}\PYG{o}{.}\PYG{n}{y}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{n}{M}\PYG{o}{.}\PYG{n}{z}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{n}{M}\PYG{o}{.}\PYG{n}{w}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{n}{M}\PYG{o}{.}\PYG{n}{w}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}
\PYG{g+go}{6.0 4.0 3.5 0 1}
\end{sphinxVerbatim}

In general, it may be difficult to determine a valid value of $M$.   Thus, this transformation may
result in a restriction or relaxation of the original problem (depending on where the big-M values
are introduced).


\section{Multilevel Representations}
\label{\detokenize{representations/mpr:multilevel-representations}}\label{\detokenize{representations/mpr::doc}}
PAO includes several \sphinxstyleemphasis{Multilevel Problem Representations} (MPRs)
that represent multilevel optimization problems with an explicit,
compact representation that simplifies the implementation of solvers for
bilevel, trilevel and other multilevel optimization problems.  These MPRs
express objective and constraints using vector and matrix data types.
However, they organize these data types to provide a semantically clear
organization of multilevel problems.  Additionally, the MPRs provide
checks to ensure the consistency of the data within and across levels.

The classes {\hyperref[\detokenize{reference/mpr:pao.mpr.repn.LinearMultilevelProblem}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LinearMultilevelProblem}}}}}
and {\hyperref[\detokenize{reference/mpr:pao.mpr.repn.QuadraticMultilevelProblem}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{QuadraticMultilevelProblem}}}}} respectively
represent linear and quadratic multilevel problems.  Although
{\hyperref[\detokenize{reference/mpr:pao.mpr.repn.QuadraticMultilevelProblem}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{QuadraticMultilevelProblem}}}}} is a generalization of the
representation in {\hyperref[\detokenize{reference/mpr:pao.mpr.repn.LinearMultilevelProblem}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LinearMultilevelProblem}}}}}, the use of tailored
representations for different classes of problems clarifies the semantic
context when using them.  For example, this allows for simple error checking
to confirm that a problem is linear.

Currently, all PAO solvers for MPRs support only linear problems, so the
following sections focus on {\hyperref[\detokenize{reference/mpr:pao.mpr.repn.LinearMultilevelProblem}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LinearMultilevelProblem}}}}}.  However,
we conclude with an example of model transformations that enable the
solution of quadratic problems using {\hyperref[\detokenize{reference/mpr:pao.mpr.repn.QuadraticMultilevelProblem}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{QuadraticMultilevelProblem}}}}}.

\begin{sphinxadmonition}{note}{Note:}
We do not expect many users to directly employ a MPR data
representation for their applications.  Perhaps this would be
desirable if their problem was already represented with matrix and
vector data.  In general, the algebraic representation supported by
Pyomo will be more convenient for large, complex applications.

We expect this representation to be more useful for researchers
developing multilevel solvers, since the MPR representations provide
structure that simplifies the expression of necessary mathematical
operations for these problems.
\end{sphinxadmonition}


\subsection{Linear Bilevel Examples}
\label{\detokenize{representations/mpr:linear-bilevel-examples}}
We consider again the bilevel problem PAO1 \eqref{equation:sand:eq-pao1}.  This problem
has has linear upper\sphinxhyphen{} and lower\sphinxhyphen{}level problems with different objectives
in each level.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{mpr}\PYG{o}{.}\PYG{n}{LinearMultilevelProblem}\PYG{p}{(}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U} \PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{add\PYGZus{}upper}\PYG{p}{(}\PYG{n}{nxR}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L} \PYG{o}{=} \PYG{n}{U}\PYG{o}{.}\PYG{n}{add\PYGZus{}lower}\PYG{p}{(}\PYG{n}{nxR}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{NINF}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{PINF}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds} \PYG{o}{=} \PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{PINF}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{U}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{L}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{L}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{maximize} \PYG{o}{=} \PYG{k+kc}{True}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{equalities} \PYG{o}{=} \PYG{k+kc}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{A}\PYG{p}{[}\PYG{n}{U}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{A}\PYG{p}{[}\PYG{n}{U}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }         \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }         \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{A}\PYG{p}{[}\PYG{n}{L}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }         \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }         \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{13}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M}\PYG{o}{.}\PYG{n}{check}\PYG{p}{(}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pao.mpr.FA}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{results} \PYG{o}{=} \PYG{n}{opt}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{M}\PYG{o}{.}\PYG{n}{U}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{values}\PYG{p}{)}
\PYG{g+go}{[6.0, 4.0]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{M}\PYG{o}{.}\PYG{n}{U}\PYG{o}{.}\PYG{n}{LL}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{values}\PYG{p}{)}
\PYG{g+go}{[2.0]}
\end{sphinxVerbatim}

The example illustrates both the flexibility of the MPR representions
in PAO but also the structure they enforce on the multilevel problem
representation.  The upper\sphinxhyphen{}level problem is created by calling the
\sphinxcode{\sphinxupquote{add\_upper()}} method, which takes arguments that specify the
variables at that level:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nxR}} \sphinxhyphen{} The number of real variables (Default: 0)

\item {} 
\sphinxcode{\sphinxupquote{nxZ}} \sphinxhyphen{} The number of general integer variables (Default: 0)

\item {} 
\sphinxcode{\sphinxupquote{nxB}} \sphinxhyphen{} The number of binary variables (Default: 0)

\end{itemize}

In each level, the variables are represented as a vector of values,
ordered in this manner.

Similarly, the \sphinxcode{\sphinxupquote{add\_lower()}} method is used to generate a lower\sphinxhyphen{}level
problem from a given level.  Note that this allows for the specification
of arbitrary nesting of levels, since a lower\sphinxhyphen{}level can be defined
relative to any other level in the model.  Additionally, multiple
lower\sphinxhyphen{}levels can be specified for relative to a single level (see below).

The \sphinxcode{\sphinxupquote{add\_upper()}} and \sphinxcode{\sphinxupquote{add\_lower()}} methods return the
corresponding level object, which is used to specify data in the model
later.

For a given level object, \sphinxcode{\sphinxupquote{Z}}, the data \sphinxcode{\sphinxupquote{Z.x}} contains
information about the decision variables.  In particular, the values
\sphinxcode{\sphinxupquote{Z.x.lower\_bounds}} and \sphinxcode{\sphinxupquote{Z.x.upper\_bounds}} can be set with arrays
of numeric values to specify lower\sphinxhyphen{} and upper\sphinxhyphen{}bounds on the decision
variables.  Note that missing lower\sphinxhyphen{} and upper\sphinxhyphen{}bounds are specified with
\sphinxcode{\sphinxupquote{numpy.NINF}} and \sphinxcode{\sphinxupquote{numpy.PINF}} respectively.

The \sphinxcode{\sphinxupquote{Z.c}} data specifies coefficients of the objective function for
this level.  This data is indexed by a level object \sphinxcode{\sphinxupquote{B}} to indicate
the data associated with the variables in \sphinxcode{\sphinxupquote{B}}.  In the example above:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{U.c{[}U{]}}} is the array of coefficients of the upper\sphinxhyphen{}level objective for the variables in the upper\sphinxhyphen{}level,

\item {} 
\sphinxcode{\sphinxupquote{U.c{[}L{]}}} is the array of coefficients of the upper\sphinxhyphen{}level objective for the variables in the lower\sphinxhyphen{}level, and

\item {} 
\sphinxcode{\sphinxupquote{L.c{[}L{]}}} is the array of coefficients of the lower\sphinxhyphen{}level objective for the variables in the lower\sphinxhyphen{}level.

\end{itemize}

Since \sphinxcode{\sphinxupquote{L.c{[}U{]}}} is not specified, it has a value \sphinxcode{\sphinxupquote{None}} that
indicates that no upper\sphinxhyphen{}level variables have non\sphinxhyphen{}zero coefficients in the
lower\sphinxhyphen{}level objective.  The \sphinxcode{\sphinxupquote{Z.A}} data specifies the matrix coefficients
for the constraints using a similar indexing notation and semantics.

The values \sphinxcode{\sphinxupquote{Z.minimize}} and \sphinxcode{\sphinxupquote{Z.maximize}} can be set to \sphinxcode{\sphinxupquote{True}}
to indicate whether the objective in \sphinxcode{\sphinxupquote{Z}} minimizes or maximizes.
(The default is minimize.)  Similarly the value \sphinxcode{\sphinxupquote{Z.inequalities}}
and \sphinxcode{\sphinxupquote{Z.equalities}} can be set to \sphinxcode{\sphinxupquote{True}} to indicate whether the
constraints in \sphinxcode{\sphinxupquote{Z}} are inequalities or equalities.  (The default
is inequalities.)  Finally, the value \sphinxcode{\sphinxupquote{Z.b}} defines the array of
constraint right\sphinxhyphen{}hand\sphinxhyphen{}side values.

The :meth:\sphinxcode{\sphinxupquote{check}} method provides a convenient sanity check that the
data is defined consistently within each level and between levels.

Note that PAO supports a consistent interface for creating a solver
interface and for applying solvers.  In fact, the user should be
aware that Pyomo and MPR solvers are named in a consistent fashion.
For example, the Pyomo solver \sphinxstylestrong{pao.pyomo.FA} calls the MPR solver
\sphinxstylestrong{pao.mpr.FA} after automatically converting the Pyomo representation
to a :class:\sphinxcode{\sphinxupquote{LinearMultilevelProblem}} representation.  This example
illustrates that values \sphinxcode{\sphinxupquote{Z.x.values}} contains the values of each level
\sphinxcode{\sphinxupquote{Z}} after optimization.


\subsection{Multilevel Examples}
\label{\detokenize{representations/mpr:multilevel-examples}}
Multilevel problems can be easily expressed using the same MPR data
representation.


\paragraph{Multiple Lower Levels}
\label{\detokenize{representations/mpr:multiple-lower-levels}}
We consider again the bilevel problem PAO2 \eqref{equation:sand:eq-pao2}, which has has
multiple lower\sphinxhyphen{}level problems.  The \sphinxstylestrong{PAO2} model can be expressed as
a linear multilevel problem as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{mpr}\PYG{o}{.}\PYG{n}{LinearMultilevelProblem}\PYG{p}{(}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U} \PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{add\PYGZus{}upper}\PYG{p}{(}\PYG{n}{nxR}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L1} \PYG{o}{=} \PYG{n}{U}\PYG{o}{.}\PYG{n}{add\PYGZus{}lower}\PYG{p}{(}\PYG{n}{nxR}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L2} \PYG{o}{=} \PYG{n}{U}\PYG{o}{.}\PYG{n}{add\PYGZus{}lower}\PYG{p}{(}\PYG{n}{nxR}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{NINF}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{PINF}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{U}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{L1}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{L2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{equalities} \PYG{o}{=} \PYG{k+kc}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{A}\PYG{p}{[}\PYG{n}{U}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L1}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L1}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds} \PYG{o}{=} \PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{PINF}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L1}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{L1}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L1}\PYG{o}{.}\PYG{n}{maximize} \PYG{o}{=} \PYG{k+kc}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L1}\PYG{o}{.}\PYG{n}{A}\PYG{p}{[}\PYG{n}{U}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }          \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }          \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L1}\PYG{o}{.}\PYG{n}{A}\PYG{p}{[}\PYG{n}{L1}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }           \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }           \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L1}\PYG{o}{.}\PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{13}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L2}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L2}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds} \PYG{o}{=} \PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{PINF}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L2}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{L2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L2}\PYG{o}{.}\PYG{n}{maximize} \PYG{o}{=} \PYG{k+kc}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L2}\PYG{o}{.}\PYG{n}{A}\PYG{p}{[}\PYG{n}{U}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}  \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }          \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }          \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}  \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L2}\PYG{o}{.}\PYG{n}{A}\PYG{p}{[}\PYG{n}{L2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }           \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }           \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L2}\PYG{o}{.}\PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{13}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pao.mpr.FA}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{results} \PYG{o}{=} \PYG{n}{opt}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{U}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{values}\PYG{p}{)}
\PYG{g+go}{[2.0, 8.0]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{L1}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{values}\PYG{p}{)}
\PYG{g+go}{[5.5]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{L2}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{values}\PYG{p}{)}
\PYG{g+go}{[0.0]}
\end{sphinxVerbatim}

The declarataion of the two lower level problems is naturally contained
within the data of the \sphinxcode{\sphinxupquote{L1}} and \sphinxcode{\sphinxupquote{L2}} objects.  Further, the
cross\sphinxhyphen{}level interactions are intuitively represented using the index
notation for the objective and constraint data objects.

Note that this more explicit representation clarifies some ambiguity in
the expression of lower\sphinxhyphen{}levels in the Pyomo representation.  The Pyomo
representation of PAO2 only specifies the fixed variables that are
\sphinxstylestrong{used} in each of the two lower\sphinxhyphen{}level problems.  PAO analyzes
the use of decision variables in Pyomo models, and treats \sphinxstyleemphasis{unused}
variables as fixed.  Thus, the Pyomo and MPR representations generate
a consistent interpretation of the variable specifications.  However,
the MPR representation is more explicit in this regard.


\paragraph{Trilevel Problems}
\label{\detokenize{representations/mpr:trilevel-problems}}
We consider again the trilevel problem described by Anadalingam
\eqref{equation:sand:eq-anadalingam}, which can be expressed as a trilevel linear problem
as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{mpr}\PYG{o}{.}\PYG{n}{LinearMultilevelProblem}\PYG{p}{(}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U} \PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{add\PYGZus{}upper}\PYG{p}{(}\PYG{n}{nxR}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L} \PYG{o}{=} \PYG{n}{U}\PYG{o}{.}\PYG{n}{add\PYGZus{}lower}\PYG{p}{(}\PYG{n}{nxR}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{B} \PYG{o}{=} \PYG{n}{L}\PYG{o}{.}\PYG{n}{add\PYGZus{}lower}\PYG{p}{(}\PYG{n}{nxR}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{B}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{B}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{minimize} \PYG{o}{=} \PYG{k+kc}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{U}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{L}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{B}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{minimize} \PYG{o}{=} \PYG{k+kc}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{L}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{B}\PYG{o}{.}\PYG{n}{minimize} \PYG{o}{=} \PYG{k+kc}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{B}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{B}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{B}\PYG{o}{.}\PYG{n}{inequalities} \PYG{o}{=} \PYG{k+kc}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{B}\PYG{o}{.}\PYG{n}{A}\PYG{p}{[}\PYG{n}{U}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{B}\PYG{o}{.}\PYG{n}{A}\PYG{p}{[}\PYG{n}{L}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{B}\PYG{o}{.}\PYG{n}{A}\PYG{p}{[}\PYG{n}{B}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{B}\PYG{o}{.}\PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}


\paragraph{Bilinear Problems}
\label{\detokenize{representations/mpr:bilinear-problems}}
The {\hyperref[\detokenize{reference/mpr:pao.mpr.repn.QuadraticMultilevelProblem}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{QuadraticMultilevelProblem}}}}} class can represent general
quadratic problems with quadratic terms in the objective and constraints
at each level.  The special case where bilinear terms arise with an
upper\sphinxhyphen{}level binary variable multiplied with a lower\sphinxhyphen{}level variable is
common in many applications.  For this case, PAO provides a function to
linearize these bilinear terms.

We consider again the bilevel problem PAO3 \eqref{equation:sand:eq-pao3}, which is
represented and solved as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{M} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{mpr}\PYG{o}{.}\PYG{n}{QuadraticMultilevelProblem}\PYG{p}{(}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U} \PYG{o}{=} \PYG{n}{M}\PYG{o}{.}\PYG{n}{add\PYGZus{}upper}\PYG{p}{(}\PYG{n}{nxR}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{nxB}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L} \PYG{o}{=} \PYG{n}{U}\PYG{o}{.}\PYG{n}{add\PYGZus{}lower}\PYG{p}{(}\PYG{n}{nxR}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{NINF}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{PINF}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{lower\PYGZus{}bounds} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{upper\PYGZus{}bounds} \PYG{o}{=} \PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{PINF}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{U}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{L}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{c}\PYG{p}{[}\PYG{n}{L}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{maximize} \PYG{o}{=} \PYG{k+kc}{True}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{A}\PYG{p}{[}\PYG{n}{U}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,}  \PYG{l+m+mi}{1}\PYG{p}{,}  \PYG{l+m+mi}{0}\PYG{p}{,}  \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }         \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}  \PYG{l+m+mi}{0}\PYG{p}{,}  \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }         \PYG{p}{[} \PYG{l+m+mi}{0}\PYG{p}{,}  \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+gp}{... }         \PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{U}\PYG{o}{.}\PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{A}\PYG{p}{[}\PYG{n}{U}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }         \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }         \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{A}\PYG{p}{[}\PYG{n}{L}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }         \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}
\PYG{g+gp}{... }         \PYG{p}{[} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{Q}\PYG{p}{[}\PYG{n}{U}\PYG{p}{,}\PYG{n}{L}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L}\PYG{o}{.}\PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{13}\PYG{p}{]}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{lmr}\PYG{p}{,} \PYG{n}{soln} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{mpr}\PYG{o}{.}\PYG{n}{linearize\PYGZus{}bilinear\PYGZus{}terms}\PYG{p}{(}\PYG{n}{M}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pao.mpr.FA}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{results} \PYG{o}{=} \PYG{n}{opt}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{lmr}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{soln}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{From}\PYG{o}{=}\PYG{n}{lmr}\PYG{p}{,} \PYG{n}{To}\PYG{o}{=}\PYG{n}{M}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{U}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{values}\PYG{p}{)}
\PYG{g+go}{[6.0, 4.0, 0, 1]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{L}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{values}\PYG{p}{)}
\PYG{g+go}{[3.5]}
\end{sphinxVerbatim}

The data \sphinxcode{\sphinxupquote{L.Q{[}U,L{]}}} specifies the bilinear terms multiplying
variables from level \sphinxcode{\sphinxupquote{U}} with variables from level \sphinxcode{\sphinxupquote{L}}, which
are included in the constraints in level \sphinxcode{\sphinxupquote{L}}.  Note that \sphinxcode{\sphinxupquote{Q}} is a
tensor, which is indexed over the constraints, upper\sphinxhyphen{}level variables
and lower\sphinxhyphen{}level variables.  A similar syntax is used to define bilinear
terms in objectives, \sphinxcode{\sphinxupquote{P}}, though that is represented as a sparse matrix.
Quadratic terms can be specified simply by using the same levels to index
\sphinxcode{\sphinxupquote{Q}} or \sphinxcode{\sphinxupquote{P}}.

Model transformations like :func:\sphinxcode{\sphinxupquote{.linearize\_bilinear\_terms}} are
described in further detail in the next section.  Note that this function
returns both the transformed model as well as a helper class that maps
solutions back to the original model.  This logic facilitates the
automation of model transformations within PAO.


\section{Solvers}
\label{\detokenize{solvers:solvers}}\label{\detokenize{solvers::doc}}
After formulating a multilevel problem, PAO users will generally need to
(1) transform the model to a standard form, and (2) apply an optimizer
to solve the problem.  The examples in the previous sections illustrate
that step (1) is often optional;  PAO automates the applications of
several model transformations, particularly for problems formulated with
Pyomo.  The following section summarizes the solvers available in PAO,
and describes how PAO manages solvers. Section \DUrole{xref,std,std-ref}{transformations}
describes model transformations in PAO.


\subsection{Summary of PAO Solvers}
\label{\detokenize{solvers:summary-of-pao-solvers}}
The following summarizes the current solvers available in PAO:
\begin{itemize}
\item {} 
pao.mpr.FA, pao.pyomo.FA
\begin{quote}

PAO solver for Multilevel Problem Representations that define linear
bilevel problems.  Solver uses big\sphinxhyphen{}M relaxations discussed by Fortuny\sphinxhyphen{}
Amat and McCarl (1981).
\end{quote}

\item {} 
pao.mpr.MIBS, pao.pyomo.MIBS
\begin{quote}

PAO solver for Multilevel Problem Representations using the COIN\sphinxhyphen{}OR
MibS solver by Tahernejad, Ralphs, and DeNegre (2020).
\end{quote}

\item {} 
pao.mpr.PCCG, pao.pyomo.PCCG
\begin{quote}

PAO solver for Multilevel Problem Representations that define linear
bilevel problems. Solver uses projected column constraint generation
algorithm described by Yue et al. (2017).
\end{quote}

\item {} 
pao.mpr.REG, pao.pyomo.REG
\begin{quote}

PAO solver for Multilevel Problem Representations that define linear
bilevel problems.  Solver uses regularization discussed by Scheel and
Scholtes (2000) and Ralph and Wright (2004).
\end{quote}

\end{itemize}

The following table summarize key features of the problems these solvers
can be applied to:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\hline
\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{6}}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&\sphinxstartmulticolumn{4}%
\begin{varwidth}[t]{\sphinxcolwidth{4}{6}}
\sphinxstylestrong{Solver}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{6}}
\sphinxstylestrong{Problem Feature}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxstyleemphasis{FA}
&
\sphinxstyleemphasis{REG}
&
\sphinxstyleemphasis{PCCG}
&
\sphinxstyleemphasis{MibS}
\\
\hline\sphinxmultirow{3}{8}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{6}}
Equation
Structure
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
Linear
&
Y
&
Y
&
Y
&
Y
\\
\cline{2-6}\sphinxtablestrut{8}&
Bilinear
&
Y
&
Y
&
Y
&
Y
\\
\cline{2-6}\sphinxtablestrut{8}&
Nonlinear
&&&&\\
\hline\sphinxmultirow{2}{24}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{6}}
Upper\sphinxhyphen{}Level
Variables
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
Integer
&
Y
&&
Y
&
Y
\\
\cline{2-6}\sphinxtablestrut{24}&
Real
&
Y
&
Y
&
Y
&
Y
\\
\hline\sphinxmultirow{2}{35}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{6}}
Lower\sphinxhyphen{}Level
Variables
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
Integer
&&&
Y
&
Y
\\
\cline{2-6}\sphinxtablestrut{35}&
Real
&
Y
&
Y
&
Y
&
Y
\\
\hline\sphinxmultirow{3}{46}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{6}}
Multilevel
Representation
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
Bilevel
&
Y
&
Y
&
Y
&
Y
\\
\cline{2-6}\sphinxtablestrut{46}&
Trilevel
&&&&\\
\cline{2-6}\sphinxtablestrut{46}&
k\sphinxhyphen{}Bilevel
&
Y
&
Y
&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
The iterface to MibS is a prototype that has not been well\sphinxhyphen{}tested.
This interface will be documented and finalized in an upcoming
release of PAO.
\end{sphinxadmonition}


\subsection{The Solver Interface}
\label{\detokenize{solvers:the-solver-interface}}
The \sphinxcode{\sphinxupquote{Solver}} object provides a single interface for setting up
an interface to optimizers in PAO.  This includes \sphinxstyleemphasis{both} PAO solvers for
multilevel optimization problems, but also interfaces to conventional
numerical solvers that are used by PAO solvers.  We illustrate this
distinction with the following example, which optimizes the PAO1
\eqref{equation:sand:eq-pao1} example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Create an interface to the PAO FA solver}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pao.pyomo.FA}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Optimize the model}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} By default, FA uses the glpk MIP solver}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{results} \PYG{o}{=} \PYG{n}{opt}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{n}{M}\PYG{o}{.}\PYG{n}{y}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{z}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}
\PYG{g+go}{6.0 4.0 2.0}


\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Create an interface to the PAO FA solver, using cbc}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pao.pyomo.FA}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{mip\PYGZus{}solver}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cbc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Optimize the model using cbc}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{results} \PYG{o}{=} \PYG{n}{opt}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{n}{M}\PYG{o}{.}\PYG{n}{y}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{z}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}
\PYG{g+go}{6.0 4.0 2.0}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{Solver}} object is initialized using the solver name followed
by solver\sphinxhyphen{}specific options.  In this case, the FA algorithm accepts
the \sphinxcode{\sphinxupquote{mip\_solver}} option that specifies the mixed\sphinxhyphen{}integer programming
(MIP) solver that is used to solve the MIP that is generated by FA after
reformulating the bilevel problem.  The value of \sphinxcode{\sphinxupquote{mip\_solver}} is itself
an optimizer.  As illustrated here, this option can simply be the string
name of the MIP solver that will be used.  However, the \sphinxcode{\sphinxupquote{Solver}}
object can be used to define a MIP solver interface as well:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Create an interface to the cbc MIP solver}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mip} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cbc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Create an interface to the PAO FA solver, using cbc}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pao.pyomo.FA}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{mip\PYGZus{}solver}\PYG{o}{=}\PYG{n}{mip}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Optimize the model using cbc}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{results} \PYG{o}{=} \PYG{n}{opt}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{n}{M}\PYG{o}{.}\PYG{n}{y}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{z}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}
\PYG{g+go}{6.0 4.0 2.0}
\end{sphinxVerbatim}

This enables the customization of the MIP solver used by FA.  Note that
the \sphinxcode{\sphinxupquote{solve()}} method accepts the same options as \sphinxcode{\sphinxupquote{Solve}}.
This allows for more dynamic specification of solver options:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Create an interface to the cbc MIP solver}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cbc} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cbc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Create an interface to the glpk MIP solver}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{glpk} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{glpk}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Create an interface to the PAO FA solver}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pao.pyomo.FA}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Optimize the model using cbc}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{results} \PYG{o}{=} \PYG{n}{opt}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{M}\PYG{p}{,} \PYG{n}{mip\PYGZus{}solver}\PYG{o}{=}\PYG{n}{cbc}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{n}{M}\PYG{o}{.}\PYG{n}{y}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{z}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}
\PYG{g+go}{6.0 4.0 2.0}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Optimize the model using glpk}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{results} \PYG{o}{=} \PYG{n}{opt}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{M}\PYG{p}{,} \PYG{n}{mip\PYGZus{}solver}\PYG{o}{=}\PYG{n}{glpk}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{M}\PYG{o}{.}\PYG{n}{x}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{n}{M}\PYG{o}{.}\PYG{n}{y}\PYG{o}{.}\PYG{n}{value}\PYG{p}{,} \PYG{n}{M}\PYG{o}{.}\PYG{n}{L}\PYG{o}{.}\PYG{n}{z}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}
\PYG{g+go}{6.0 4.0 2.0}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
The \sphinxcode{\sphinxupquote{solve()}} current passes unknown keyword arguments to the
optimizer used by PAO solvers, but this feature will be disabled.
\end{sphinxadmonition}


\paragraph{PAO Solvers}
\label{\detokenize{solvers:pao-solvers}}
Solvers developed in PAO have names that begin with \sphinxcode{\sphinxupquote{pao.}}.
The current set of available PAO solvers can be queried using the
\sphinxcode{\sphinxupquote{Solver}} object:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{name} \PYG{o+ow}{in} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{Solver}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}
\PYG{g+go}{pao.mpr.FA}
\PYG{g+go}{pao.mpr.MIBS}
\PYG{g+go}{pao.mpr.PCCG}
\PYG{g+go}{pao.mpr.REG}
\PYG{g+go}{pao.pyomo.FA}
\PYG{g+go}{pao.pyomo.MIBS}
\PYG{g+go}{pao.pyomo.PCCG}
\PYG{g+go}{pao.pyomo.REG}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pao}\PYG{o}{.}\PYG{n}{Solver}\PYG{o}{.}\PYG{n}{summary}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{pao.mpr.FA}
\PYG{g+go}{    PAO solver for Multilevel Problem Representations that define linear}
\PYG{g+go}{    bilevel problems.  Solver uses big\PYGZhy{}M relaxations discussed by Fortuny\PYGZhy{}}
\PYG{g+go}{    Amat and McCarl (1981).}

\PYG{g+go}{pao.mpr.MIBS}
\PYG{g+go}{    PAO solver for Multilevel Problem Representations using the COIN\PYGZhy{}OR}
\PYG{g+go}{    MibS solver by Tahernejad, Ralphs, and DeNegre (2020).}

\PYG{g+go}{pao.mpr.PCCG}
\PYG{g+go}{    PAO solver for Multilevel Problem Representations that define linear}
\PYG{g+go}{    bilevel problems. Solver uses projected column constraint generation}
\PYG{g+go}{    algorithm described by Yue et al. (2017).}

\PYG{g+go}{pao.mpr.REG}
\PYG{g+go}{    PAO solver for Multilevel Problem Representations that define linear}
\PYG{g+go}{    bilevel problems.  Solver uses regularization discussed by Scheel and}
\PYG{g+go}{    Scholtes (2000) and Ralph and Wright (2004).}

\PYG{g+go}{pao.pyomo.FA}
\PYG{g+go}{    PAO solver for Pyomo models that define linear and bilinear bilevel}
\PYG{g+go}{    problems.  Solver uses big\PYGZhy{}M relaxations discussed by Fortuny\PYGZhy{}Amat and}
\PYG{g+go}{    McCarl (1981).}

\PYG{g+go}{pao.pyomo.MIBS}
\PYG{g+go}{    PAO solver for Multilevel Problem Representations using the COIN\PYGZhy{}OR}
\PYG{g+go}{    MibS solver by Tahernejad, Ralphs, and DeNegre (2020).}

\PYG{g+go}{pao.pyomo.PCCG}
\PYG{g+go}{    PAO solver for Pyomo models that define linear and bilinear bilevel}
\PYG{g+go}{    problems.  Solver uses projected column constraint generation}
\PYG{g+go}{    algorithm described by Yue et al. (2017)}

\PYG{g+go}{pao.pyomo.REG}
\PYG{g+go}{    PAO solver for Pyomo models that define linear and bilinear bilevel}
\PYG{g+go}{    problems.  Solver uses regularization discussed by Scheel and Scholtes}
\PYG{g+go}{    (2000) and Ralph and Wright (2004).}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{solve()}} method includes documentation describing the keyword
arguments for a specific solver.  For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pao.pyomo.FA}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{help}\PYG{p}{(}\PYG{n}{opt}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{)}
\PYG{g+go}{Help on method solve in module pao.pyomo.solvers.mpr\PYGZus{}solvers:}

\PYG{g+go}{solve(model, **options) method of pao.pyomo.solvers.mpr\PYGZus{}solvers.PyomoSubmodelSolver\PYGZus{}FA instance}
\PYG{g+go}{    Executes the solver and loads the solution into the model.}

\PYG{g+go}{    Parameters}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{    model}
\PYG{g+go}{        The model that is being optimized.}
\PYG{g+go}{    options}
\PYG{g+go}{        Keyword options that are used to configure the solver.}

\PYG{g+go}{    Keyword Arguments}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{    tee}
\PYG{g+go}{      If True, then solver output is streamed to stdout. (default is False)}
\PYG{g+go}{    load\PYGZus{}solutions}
\PYG{g+go}{      If True, then the finale solution is loaded into the model. (default is True)}
\PYG{g+go}{    linearize\PYGZus{}bigm}
\PYG{g+go}{      The name of the big\PYGZhy{}M value used to linearize bilinear terms.  If this is not specified, then the solver will throw an error if bilinear terms exist in the model.}
\PYG{g+go}{    mip\PYGZus{}solver}
\PYG{g+go}{      The MIP solver used by FA.  (default is glpk)}

\PYG{g+go}{    Returns}
\PYG{g+go}{    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{    Results}
\PYG{g+go}{        A summary of the optimization results.}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{solve()}} method returns a results object that contains
data about the optimization process.  In particular, this object
contains information about the termination conditions for the solver.
The \sphinxcode{\sphinxupquote{check\_optimal\_termination()}} method can be used confirm that the
termination condition indicates that an optimal solution was found.  For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{nlp} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ipopt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{print\PYGZus{}level}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pao.pyomo.REG}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{nlp\PYGZus{}solver}\PYG{o}{=}\PYG{n}{nlp}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{results} \PYG{o}{=} \PYG{n}{opt}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{results}\PYG{o}{.}\PYG{n}{solver}\PYG{o}{.}\PYG{n}{termination\PYGZus{}condition}\PYG{p}{)}
\PYG{g+go}{TerminationCondition.optimal}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{results}\PYG{o}{.}\PYG{n}{check\PYGZus{}optimal\PYGZus{}termination}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{True}
\end{sphinxVerbatim}


\paragraph{Pyomo Solvers}
\label{\detokenize{solvers:pyomo-solvers}}
The \sphinxcode{\sphinxupquote{Solver}} object also provides a convenient interface to
conventional numerical solvers.  Currently, solver objects constructed
by \sphinxcode{\sphinxupquote{Solver}} are simple wrappers around Pyomo optimization
solver objects.  This interface supports two types of solver
interfaces: (1) solvers that execute locally, and (2) solvers that execute
on remote servers.

When optimizating a \sphinxstylestrong{Pyomo} model, solver parameters can be setup
both when the solver interface is created and when a model is optimized.
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} This is a nonlinear toy problem modeled with Pyomo}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{NLP} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{ConcreteModel}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{A} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{NLP}\PYG{o}{.}\PYG{n}{x} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Var}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{bounds}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{,} \PYG{n}{initialize}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{NLP}\PYG{o}{.}\PYG{n}{o} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Objective}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{pe}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{NLP}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{A}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{NLP}\PYG{o}{.}\PYG{n}{c} \PYG{o}{=} \PYG{n}{pe}\PYG{o}{.}\PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr}\PYG{o}{=}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{NLP}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{A}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{nlp} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ipopt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{print\PYGZus{}level}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Apply ipopt with print level 3}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{results} \PYG{o}{=} \PYG{n}{nlp}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{NLP}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Override the default print level to using 5}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{results} \PYG{o}{=} \PYG{n}{nlp}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{NLP}\PYG{p}{,} \PYG{n}{print\PYGZus{}level}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}
\end{sphinxVerbatim}

However, PAO users will typically setup solver parameters when the
Pyomo solver is initially created:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{nlp} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ipopt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{print\PYGZus{}level}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{opt} \PYG{o}{=} \PYG{n}{pao}\PYG{o}{.}\PYG{n}{Solver}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pao.pyomo.REG}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{nlp\PYGZus{}solver}\PYG{o}{=}\PYG{n}{nlp}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{results} \PYG{o}{=} \PYG{n}{opt}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}
\end{sphinxVerbatim}

When executing locally, the \sphinxcode{\sphinxupquote{executable}} option can be used
to explicitly specify the path to the executable that is used by this solver.
This is helpful in contexts where Pyomo is not automatically finding the \sphinxstyleemphasis{correct}
optimizer executable in a user’s shell environment.

When executing on a remote server, the \sphinxcode{\sphinxupquote{server}} is used to
specify the server that is used.  Currently, only the \sphinxcode{\sphinxupquote{neos}} server is
supported, which allows the user to perform optimization at NEOS \sphinxcite{neos}.
The NEOS server requires a user to specify a valid email address:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{}\PYGZgt{}\PYGZgt{} nlp = pao.Solver(\PYGZsq{}ipopt\PYGZsq{}, server=\PYGZsq{}neos\PYGZsq{}, email=\PYGZsq{}pao@gmail.com\PYGZsq{})
\PYGZgt{}\PYGZgt{}\PYGZgt{} opt = pao.Solver(\PYGZsq{}pao.pyomo.REG\PYGZsq{}, nlp\PYGZus{}solver=nlp)
\PYGZgt{}\PYGZgt{}\PYGZgt{} results = opt.solve(M)
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
There is no common reference for solver\sphinxhyphen{}specific parameters for the
solvers available in Pyomo.  These are generally documented with
solver documentation, and users should expect to contact solver
developers to learn about these.
\end{sphinxadmonition}


\section{Model Transformations}
\label{\detokenize{xfrm:model-transformations}}\label{\detokenize{xfrm:transformations}}\label{\detokenize{xfrm::doc}}
PAO includes a variety of functions that transform models, which generally
are applied as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{}\PYGZgt{}\PYGZgt{} new\PYGZus{}model, soln = transform\PYGZus{}function(old\PYGZus{}model)
\end{sphinxVerbatim}

Here, the function \sphinxcode{\sphinxupquote{transform\_func}} generates the model \sphinxcode{\sphinxupquote{new\_model}} from the model \sphinxcode{\sphinxupquote{old\_model}}.  The
object \sphinxcode{\sphinxupquote{soln}} is used to map a solution back to the old model:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{}\PYGZgt{}\PYGZgt{} soln.copy(From=new\PYGZus{}model, To=old\PYGZus{}model)
\end{sphinxVerbatim}

The following transformation functions are documented and suitable for use by end\sphinxhyphen{}users:
\begin{itemize}
\item {} 
{\hyperref[\detokenize{reference/pyomo:pao.pyomo.convert.convert_pyomo2MultilevelProblem}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pao.pyomo.convert.convert\_pyomo2MultilevelProblem()}}}}}
\begin{quote}

This function generates a {\hyperref[\detokenize{reference/mpr:pao.mpr.repn.LinearMultilevelProblem}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LinearMultilevelProblem}}}}} or
{\hyperref[\detokenize{reference/mpr:pao.mpr.repn.QuadraticMultilevelProblem}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{QuadraticMultilevelProblem}}}}} from a Pyomo model.  By default,
all constraints in the MPR representation are inequalities.
\end{quote}

\item {} 
{\hyperref[\detokenize{reference/mpr:pao.mpr.convert_repn.linearize_bilinear_terms}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pao.mpr.convert\_repn.linearize\_bilinear\_terms()}}}}}
\begin{quote}

This function generates a {\hyperref[\detokenize{reference/mpr:pao.mpr.repn.LinearMultilevelProblem}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LinearMultilevelProblem}}}}} from a {\hyperref[\detokenize{reference/mpr:pao.mpr.repn.QuadraticMultilevelProblem}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{QuadraticMultilevelProblem}}}}}
that only contains bilinear terms.  This transformation currently is limited to
MPRs that only contain inequality constraints.
\end{quote}

\item {} 
{\hyperref[\detokenize{reference/mpr:pao.mpr.convert_repn.convert_to_standard_form}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pao.mpr.convert\_repn.convert\_to\_standard\_form()}}}}}
\begin{quote}

This function generates an equivalent linear multilevel representation for which all
variables are non\sphinxhyphen{}negative and all constraints have the same form (inequalities or equalities).
This simplifies the implementation of solvers, which typically assume a standard form
for subproblems.
\end{quote}

\end{itemize}


\section{Library Reference}
\label{\detokenize{reference:library-reference}}\label{\detokenize{reference::doc}}
The following classes and functions represent the core functionality
in PAO:


\subsection{Solver API}
\label{\detokenize{reference/solverapi:solver-api}}\label{\detokenize{reference/solverapi::doc}}\index{SolverAPI (class in pao.common.solver)@\spxentry{SolverAPI}\spxextra{class in pao.common.solver}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.SolverAPI}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{SolverAPI}}}
The base class for all PAO solvers.

The SolverAPI class defines a consistent API for optimization solvers.
\index{\_\_bool\_\_() (SolverAPI method)@\spxentry{\_\_bool\_\_()}\spxextra{SolverAPI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.SolverAPI.__bool__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_bool\_\_}}}{}{}
Raises an error because this class cannot be interpreted with a boolean.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{RuntimeError}} \textendash{} Casting a solver to bool is not allowed.

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_enter\_\_() (SolverAPI method)@\spxentry{\_\_enter\_\_()}\spxextra{SolverAPI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.SolverAPI.__enter__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_enter\_\_}}}{}{}
Setup a solver and return it within a context manager.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Return a reference to \sphinxstylestrong{self}.

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{reference/solverapi:pao.common.solver.SolverAPI}]{\sphinxcrossref{SolverAPI}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_exit\_\_() (SolverAPI method)@\spxentry{\_\_exit\_\_()}\spxextra{SolverAPI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.SolverAPI.__exit__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_exit\_\_}}}{\emph{\DUrole{n}{t}}, \emph{\DUrole{n}{v}}, \emph{\DUrole{n}{traceback}}}{}
Cleanup the solver at the end of a context manager.

\end{fulllineitems}

\index{available() (SolverAPI method)@\spxentry{available()}\spxextra{SolverAPI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.SolverAPI.available}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{available}}}{}{}
Returns a bool indicating if the solver can be executed.

The default behavior is to always return \sphinxtitleref{True}, but this method
can be overloaded in a subclass to support solver\sphinxhyphen{}specific logic
(e.g.  to confirm that a solver license is available).
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver can be executed.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_persistent() (SolverAPI method)@\spxentry{is\_persistent()}\spxextra{SolverAPI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.SolverAPI.is_persistent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_persistent}}}{}{}
Returns True if the solver is persistent.

Persistent solvers maintain the model representation in memory,
which enables performance optimization when a problem is resolved
after changing initial conditions or tweaking model parameters.

The default is to return False, but this method can be overloaded
in a subclass to support solver\sphinxhyphen{}specific logic.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver is persistent.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{solve() (SolverAPI method)@\spxentry{solve()}\spxextra{SolverAPI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.SolverAPI.solve}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{n}{model}}, \emph{\DUrole{o}{**}\DUrole{n}{options}}}{}
Executes the solver and loads the solution into the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{model}} \textendash{} The model that is being optimized.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{options}} \textendash{} Keyword options that are used to configure the solver.

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tee}} \textendash{} If True, then solver output is streamed to stdout. (default is False)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{load\_solutions}} \textendash{} If True, then the finale solution is loaded into the model. (default is True)

\end{itemize}

\item[{Returns}] \leavevmode
A summary of the optimization results.

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{reference/solverapi:pao.common.solver.Results}]{\sphinxcrossref{Results}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{valid\_license() (SolverAPI method)@\spxentry{valid\_license()}\spxextra{SolverAPI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.SolverAPI.valid_license}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{valid\_license}}}{}{}
Returns a bool indicating if the solver has a valid license.

The default behavior is to always return \sphinxtitleref{True}, but this method
can be overloaded in a subclass to support solver\sphinxhyphen{}specific logic
(e.g.  to check the solver license).
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver license is valid.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{version() (SolverAPI method)@\spxentry{version()}\spxextra{SolverAPI method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.SolverAPI.version}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{version}}}{}{}
Returns a tuple that describes the solver version.

The return value is a tuple of strings.  A typical format is (major, minor, patch), but this
is not required. The default behavior is to return an empty tuple.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The solver version.

\item[{Return type}] \leavevmode
tuple

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SolverFactory (class in pao.common.solver)@\spxentry{SolverFactory}\spxextra{class in pao.common.solver}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.SolverFactory}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{SolverFactory}}}
A class that manages a registry of solvers.

A solver factory manages a registry that enables
solvers to be created by name.
\index{\_\_call\_\_() (SolverFactory method)@\spxentry{\_\_call\_\_()}\spxextra{SolverFactory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.SolverFactory.__call__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_call\_\_}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{o}{**}\DUrole{n}{options}}}{}
Constructs the specified solver.

This method creates a class instance for the solver that is specified.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The name of a solver

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{options}} \textendash{} Keyword options that are used to configure the solver.

\end{itemize}

\item[{Returns}] \leavevmode
A solver class instance for the solver that is specified.

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{reference/solverapi:pao.common.solver.SolverAPI}]{\sphinxcrossref{SolverAPI}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_iter\_\_() (SolverFactory method)@\spxentry{\_\_iter\_\_()}\spxextra{SolverFactory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.SolverFactory.__iter__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_iter\_\_}}}{}{}~\begin{quote}\begin{description}
\item[{Yields}] \leavevmode
\sphinxstyleemphasis{string} \textendash{} Yields the next solver name that has been registered

\end{description}\end{quote}

\end{fulllineitems}

\index{description() (SolverFactory method)@\spxentry{description()}\spxextra{SolverFactory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.SolverFactory.description}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{description}}}{\emph{\DUrole{n}{name}}}{}
Returns the description of the specified solver.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The name of a solver

\item[{Returns}] \leavevmode
A short description of the specified solver

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{register() (SolverFactory method)@\spxentry{register()}\spxextra{SolverFactory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.SolverFactory.register}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{register}}}{\emph{\DUrole{n}{cls}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}}, \emph{\DUrole{n}{name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{doc}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Register a solver with the specified name.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cls}} \textendash{} Class type for the solver

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Unique name of the solver

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{doc}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Short description of the solver

\end{itemize}

\item[{Returns}] \leavevmode
If the \sphinxstylestrong{cls} parameter is None, then a class
decorator function
is returned that can be used to register a solver.

\item[{Return type}] \leavevmode
decorator

\end{description}\end{quote}

\end{fulllineitems}

\index{summary() (SolverFactory method)@\spxentry{summary()}\spxextra{SolverFactory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.SolverFactory.summary}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{summary}}}{}{}
Print a summary of all solvers.

\end{fulllineitems}


\end{fulllineitems}

\index{Results (class in pao.common.solver)@\spxentry{Results}\spxextra{class in pao.common.solver}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.Results}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Results}}}{\emph{\DUrole{n}{found\_feasible\_solution}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
The results object.
\index{\_\_str\_\_() (Results method)@\spxentry{\_\_str\_\_()}\spxextra{Results method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.Results.__str__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_str\_\_}}}{}{}
Generate a string summary of this results object.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A string summarizing the data in this object.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_optimal\_termination() (Results method)@\spxentry{check\_optimal\_termination()}\spxextra{Results method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.Results.check_optimal_termination}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_optimal\_termination}}}{}{}
This function returns True if the termination condition for the solver
is ‘optimal’, ‘locallyOptimal’, or ‘globallyOptimal’, and the status is ‘ok’
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{found\_feasible\_solution() (Results method)@\spxentry{found\_feasible\_solution()}\spxextra{Results method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.Results.found_feasible_solution}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{found\_feasible\_solution}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True if at least one feasible solution was found. False otherwise.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_from() (Results method)@\spxentry{load\_from()}\spxextra{Results method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.Results.load_from}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{load\_from}}}{\emph{\DUrole{n}{model}}}{}
Load solution from the model.

When completed, this results object contains only one solution, which corresponds
to the solution in the model.

\end{fulllineitems}

\index{store\_to() (Results method)@\spxentry{store\_to()}\spxextra{Results method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.Results.store_to}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{store\_to}}}{\emph{\DUrole{n}{model}}, \emph{\DUrole{n}{i}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
Store the solution in this object into the given model.

A results object may contain one or more solutions. This method
copies the \sphinxstylestrong{i}\sphinxhyphen{}th solution into the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{i}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The index of the solution copied into the model.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{TerminationCondition (class in pao.common.solver)@\spxentry{TerminationCondition}\spxextra{class in pao.common.solver}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.TerminationCondition}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{TerminationCondition}}}{\emph{\DUrole{n}{value}}}{}
The TerminationCondition class defines a enumeration of optimization termination conditions.
\index{error (TerminationCondition attribute)@\spxentry{error}\spxextra{TerminationCondition attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.TerminationCondition.error}}\pysigline{\sphinxbfcode{\sphinxupquote{error}}\sphinxbfcode{\sphinxupquote{ = 11}}}
The solver exited due to an error

\end{fulllineitems}

\index{globallyOptimal (TerminationCondition attribute)@\spxentry{globallyOptimal}\spxextra{TerminationCondition attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.TerminationCondition.globallyOptimal}}\pysigline{\sphinxbfcode{\sphinxupquote{globallyOptimal}}\sphinxbfcode{\sphinxupquote{ = 7}}}
The solver exited with a locally optimal solution

\end{fulllineitems}

\index{infeasible (TerminationCondition attribute)@\spxentry{infeasible}\spxextra{TerminationCondition attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.TerminationCondition.infeasible}}\pysigline{\sphinxbfcode{\sphinxupquote{infeasible}}\sphinxbfcode{\sphinxupquote{ = 9}}}
The solver exited because the problem is infeasible

\end{fulllineitems}

\index{infeasibleOrUnbounded (TerminationCondition attribute)@\spxentry{infeasibleOrUnbounded}\spxextra{TerminationCondition attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.TerminationCondition.infeasibleOrUnbounded}}\pysigline{\sphinxbfcode{\sphinxupquote{infeasibleOrUnbounded}}\sphinxbfcode{\sphinxupquote{ = 10}}}
The solver exited because the problem is either infeasible or unbounded

\end{fulllineitems}

\index{interrupted (TerminationCondition attribute)@\spxentry{interrupted}\spxextra{TerminationCondition attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.TerminationCondition.interrupted}}\pysigline{\sphinxbfcode{\sphinxupquote{interrupted}}\sphinxbfcode{\sphinxupquote{ = 12}}}
The solver exited because it was interrupted

\end{fulllineitems}

\index{licensingProblems (TerminationCondition attribute)@\spxentry{licensingProblems}\spxextra{TerminationCondition attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.TerminationCondition.licensingProblems}}\pysigline{\sphinxbfcode{\sphinxupquote{licensingProblems}}\sphinxbfcode{\sphinxupquote{ = 13}}}
The solver exited due to licensing problems

\end{fulllineitems}

\index{locallyOptimal (TerminationCondition attribute)@\spxentry{locallyOptimal}\spxextra{TerminationCondition attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.TerminationCondition.locallyOptimal}}\pysigline{\sphinxbfcode{\sphinxupquote{locallyOptimal}}\sphinxbfcode{\sphinxupquote{ = 6}}}
The solver exited with a locally optimal solution

\end{fulllineitems}

\index{maxIterations (TerminationCondition attribute)@\spxentry{maxIterations}\spxextra{TerminationCondition attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.TerminationCondition.maxIterations}}\pysigline{\sphinxbfcode{\sphinxupquote{maxIterations}}\sphinxbfcode{\sphinxupquote{ = 2}}}
The solver exited due to an iteration limit

\end{fulllineitems}

\index{maxTimeLimit (TerminationCondition attribute)@\spxentry{maxTimeLimit}\spxextra{TerminationCondition attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.TerminationCondition.maxTimeLimit}}\pysigline{\sphinxbfcode{\sphinxupquote{maxTimeLimit}}\sphinxbfcode{\sphinxupquote{ = 1}}}
The solver exited due to a time limit

\end{fulllineitems}

\index{minStepLength (TerminationCondition attribute)@\spxentry{minStepLength}\spxextra{TerminationCondition attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.TerminationCondition.minStepLength}}\pysigline{\sphinxbfcode{\sphinxupquote{minStepLength}}\sphinxbfcode{\sphinxupquote{ = 4}}}
The solver exited due to a minimum step length

\end{fulllineitems}

\index{objectiveLimit (TerminationCondition attribute)@\spxentry{objectiveLimit}\spxextra{TerminationCondition attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.TerminationCondition.objectiveLimit}}\pysigline{\sphinxbfcode{\sphinxupquote{objectiveLimit}}\sphinxbfcode{\sphinxupquote{ = 3}}}
The solver exited due to an objective limit

\end{fulllineitems}

\index{optimal (TerminationCondition attribute)@\spxentry{optimal}\spxextra{TerminationCondition attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.TerminationCondition.optimal}}\pysigline{\sphinxbfcode{\sphinxupquote{optimal}}\sphinxbfcode{\sphinxupquote{ = 5}}}
The solver exited with an optimal solution

\end{fulllineitems}

\index{unbounded (TerminationCondition attribute)@\spxentry{unbounded}\spxextra{TerminationCondition attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.TerminationCondition.unbounded}}\pysigline{\sphinxbfcode{\sphinxupquote{unbounded}}\sphinxbfcode{\sphinxupquote{ = 8}}}
The solver exited because the problem is unbounded

\end{fulllineitems}

\index{unknown (TerminationCondition attribute)@\spxentry{unknown}\spxextra{TerminationCondition attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/solverapi:pao.common.solver.TerminationCondition.unknown}}\pysigline{\sphinxbfcode{\sphinxupquote{unknown}}\sphinxbfcode{\sphinxupquote{ = 0}}}
unknown serves as both a default value, and it is used when no other enum member makes sense

\end{fulllineitems}


\end{fulllineitems}



\subsection{Pyomo Models}
\label{\detokenize{reference/pyomo:pyomo-models}}\label{\detokenize{reference/pyomo::doc}}

\paragraph{Pyomo Representation}
\label{\detokenize{reference/pyomo:pyomo-representation}}\index{SubModel (class in pao.pyomo.components)@\spxentry{SubModel}\spxextra{class in pao.pyomo.components}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.components.SubModel}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{SubModel}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwds}}}{}
This Pyomo model component defines a sub\sphinxhyphen{}model in a multi\sphinxhyphen{}level problem.

Pyomo models can include nested and parallel SubModel components to express
complex multi\sphinxhyphen{}level problems.
\index{\_\_init\_\_() (SubModel method)@\spxentry{\_\_init\_\_()}\spxextra{SubModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.components.SubModel.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
The constructor for SubModel components.
\begin{quote}\begin{description}
\item[{Keyword Arguments}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{fixed}} \textendash{} A Pyomo variable or a list of Pyomo variables that are optimized by upper\sphinxhyphen{}levels in the model.

\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{*args}} \textendash{} Arguments passed to the SimpleBlock base class.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{**kwargs}} \textendash{} Other keyword arguments passed to the SimpleBlock base class.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{Model Transformations}
\label{\detokenize{reference/pyomo:model-transformations}}\index{convert\_pyomo2MultilevelProblem() (in module pao.pyomo.convert)@\spxentry{convert\_pyomo2MultilevelProblem()}\spxextra{in module pao.pyomo.convert}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.convert.convert_pyomo2MultilevelProblem}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{convert\_pyomo2MultilevelProblem}}}{\emph{\DUrole{n}{model}}, \emph{\DUrole{o}{*}}, \emph{\DUrole{n}{determinism}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{inequalities}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{linear}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Traverse the model an generate a LinearMultilevelProblem or
QuadraticMultilevelProblem.  Generate errors if this problem cannot
be represented in this form.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{model}} \textendash{} A Pyomo model object.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{determinism}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{Default: 1}}) \textendash{} 
Indicates whether the traversal of \sphinxstylestrong{model} is
ordered.  Valid values are:
\begin{itemize}
\item {} 
0 \sphinxhyphen{} Unordered traversal of \sphinxstylestrong{model}

\item {} 
1 \sphinxhyphen{} Ordered traversal of component indices in \sphinxstylestrong{model}

\item {} 
2 \sphinxhyphen{} Ordered traversal of components by name in \sphinxstylestrong{model}

\end{itemize}


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{linear}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} A flag that indicates whether the expected model representation is linear (True) or
quadratic (False).  If not specified, then no error checking is done to confirm
whether the model is linear or quadratic.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inequalities}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{Default: True}}) \textendash{} If True, then the multilevel problem object represents all
constraints as less\sphinxhyphen{}than\sphinxhyphen{}or\sphinxhyphen{}equal inequalities.  Otherwise,
the multilevel problem represents all constraints as equalities.

\end{itemize}

\item[{Returns}] \leavevmode
This object corresponds to the problem in \sphinxstylestrong{model}.

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{reference/mpr:pao.mpr.repn.LinearMultilevelProblem}]{\sphinxcrossref{LinearMultilevelProblem}}} or {\hyperref[\detokenize{reference/mpr:pao.mpr.repn.QuadraticMultilevelProblem}]{\sphinxcrossref{QuadraticMultilevelProblem}}}

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{PAO Solvers}
\label{\detokenize{reference/pyomo:pao-solvers}}\index{PyomoSubmodelSolver\_FA (class in pao.pyomo.solvers.mpr\_solvers)@\spxentry{PyomoSubmodelSolver\_FA}\spxextra{class in pao.pyomo.solvers.mpr\_solvers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_FA}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{PyomoSubmodelSolver\_FA}}}{\emph{\DUrole{o}{**}\DUrole{n}{kwds}}}{}
PAO FA solver for Pyomo models: pao.pyomo.FA

This solver converts the Pyomo model to a LinearBilevelProblem and
calls the pao.mpr.FA solver.
\index{available() (PyomoSubmodelSolver\_FA method)@\spxentry{available()}\spxextra{PyomoSubmodelSolver\_FA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_FA.available}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{available}}}{}{}
Returns a bool indicating if the solver can be executed.

The default behavior is to always return \sphinxtitleref{True}, but this method
can be overloaded in a subclass to support solver\sphinxhyphen{}specific logic
(e.g.  to confirm that a solver license is available).
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver can be executed.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_persistent() (PyomoSubmodelSolver\_FA method)@\spxentry{is\_persistent()}\spxextra{PyomoSubmodelSolver\_FA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_FA.is_persistent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_persistent}}}{}{}
Returns True if the solver is persistent.

Persistent solvers maintain the model representation in memory,
which enables performance optimization when a problem is resolved
after changing initial conditions or tweaking model parameters.

The default is to return False, but this method can be overloaded
in a subclass to support solver\sphinxhyphen{}specific logic.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver is persistent.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{solve() (PyomoSubmodelSolver\_FA method)@\spxentry{solve()}\spxextra{PyomoSubmodelSolver\_FA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_FA.solve}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{n}{model}}, \emph{\DUrole{o}{**}\DUrole{n}{options}}}{}
Executes the solver and loads the solution into the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{model}} \textendash{} The model that is being optimized.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{options}} \textendash{} Keyword options that are used to configure the solver.

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tee}} \textendash{} If True, then solver output is streamed to stdout. (default is False)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{load\_solutions}} \textendash{} If True, then the finale solution is loaded into the model. (default is True)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{linearize\_bigm}} \textendash{} The name of the big\sphinxhyphen{}M value used to linearize bilinear terms.  If this is not specified, then the solver will throw an error if bilinear terms exist in the model.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mip\_solver}} \textendash{} The MIP solver used by FA.  (default is glpk)

\end{itemize}

\item[{Returns}] \leavevmode
A summary of the optimization results.

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{reference/solverapi:pao.common.solver.Results}]{\sphinxcrossref{Results}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{valid\_license() (PyomoSubmodelSolver\_FA method)@\spxentry{valid\_license()}\spxextra{PyomoSubmodelSolver\_FA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_FA.valid_license}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{valid\_license}}}{}{}
Returns a bool indicating if the solver has a valid license.

The default behavior is to always return \sphinxtitleref{True}, but this method
can be overloaded in a subclass to support solver\sphinxhyphen{}specific logic
(e.g.  to check the solver license).
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver license is valid.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{version() (PyomoSubmodelSolver\_FA method)@\spxentry{version()}\spxextra{PyomoSubmodelSolver\_FA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_FA.version}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{version}}}{}{}
Returns a tuple that describes the solver version.

The return value is a tuple of strings.  A typical format is (major, minor, patch), but this
is not required. The default behavior is to return an empty tuple.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The solver version.

\item[{Return type}] \leavevmode
tuple

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{PyomoSubmodelSolver\_MIBS (class in pao.pyomo.solvers.mpr\_solvers)@\spxentry{PyomoSubmodelSolver\_MIBS}\spxextra{class in pao.pyomo.solvers.mpr\_solvers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_MIBS}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{PyomoSubmodelSolver\_MIBS}}}{\emph{\DUrole{o}{**}\DUrole{n}{kwds}}}{}
PAO MibS solver for Pyomo models: pao.pyomo.MIBS

This solver converts the Pyomo model to a LinearBilevelProblem and
calls the pao.mpr.MIBS solver.
\index{available() (PyomoSubmodelSolver\_MIBS method)@\spxentry{available()}\spxextra{PyomoSubmodelSolver\_MIBS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_MIBS.available}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{available}}}{}{}
Returns a bool indicating if the solver can be executed.

The default behavior is to always return \sphinxtitleref{True}, but this method
can be overloaded in a subclass to support solver\sphinxhyphen{}specific logic
(e.g.  to confirm that a solver license is available).
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver can be executed.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_persistent() (PyomoSubmodelSolver\_MIBS method)@\spxentry{is\_persistent()}\spxextra{PyomoSubmodelSolver\_MIBS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_MIBS.is_persistent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_persistent}}}{}{}
Returns True if the solver is persistent.

Persistent solvers maintain the model representation in memory,
which enables performance optimization when a problem is resolved
after changing initial conditions or tweaking model parameters.

The default is to return False, but this method can be overloaded
in a subclass to support solver\sphinxhyphen{}specific logic.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver is persistent.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{solve() (PyomoSubmodelSolver\_MIBS method)@\spxentry{solve()}\spxextra{PyomoSubmodelSolver\_MIBS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_MIBS.solve}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{n}{model}}, \emph{\DUrole{o}{**}\DUrole{n}{options}}}{}
Executes the solver and loads the solution into the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{model}} \textendash{} The model that is being optimized.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{options}} \textendash{} Keyword options that are used to configure the solver.

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tee}} \textendash{} If True, then solver output is streamed to stdout. (default is False)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{load\_solutions}} \textendash{} If True, then the finale solution is loaded into the model. (default is True)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{linearize\_bigm}} \textendash{} The name of the big\sphinxhyphen{}M value used to linearize bilinear terms.  If this is not specified, then the solver will throw an error if bilinear terms exist in the model.

\end{itemize}

\item[{Returns}] \leavevmode
A summary of the optimization results.

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{reference/solverapi:pao.common.solver.Results}]{\sphinxcrossref{Results}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{valid\_license() (PyomoSubmodelSolver\_MIBS method)@\spxentry{valid\_license()}\spxextra{PyomoSubmodelSolver\_MIBS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_MIBS.valid_license}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{valid\_license}}}{}{}
Returns a bool indicating if the solver has a valid license.

The default behavior is to always return \sphinxtitleref{True}, but this method
can be overloaded in a subclass to support solver\sphinxhyphen{}specific logic
(e.g.  to check the solver license).
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver license is valid.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{version() (PyomoSubmodelSolver\_MIBS method)@\spxentry{version()}\spxextra{PyomoSubmodelSolver\_MIBS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_MIBS.version}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{version}}}{}{}
Returns a tuple that describes the solver version.

The return value is a tuple of strings.  A typical format is (major, minor, patch), but this
is not required. The default behavior is to return an empty tuple.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The solver version.

\item[{Return type}] \leavevmode
tuple

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{PyomoSubmodelSolver\_PCCG (class in pao.pyomo.solvers.mpr\_solvers)@\spxentry{PyomoSubmodelSolver\_PCCG}\spxextra{class in pao.pyomo.solvers.mpr\_solvers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_PCCG}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{PyomoSubmodelSolver\_PCCG}}}{\emph{\DUrole{o}{**}\DUrole{n}{kwds}}}{}
PAO PCCG solver for Pyomo models: pao.pyomo.PCCG

This solver converts the Pyomo model to a LinearBilevelProblem and
calls the pao.mpr.PCCG solver.
\index{available() (PyomoSubmodelSolver\_PCCG method)@\spxentry{available()}\spxextra{PyomoSubmodelSolver\_PCCG method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_PCCG.available}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{available}}}{}{}
Returns a bool indicating if the solver can be executed.

The default behavior is to always return \sphinxtitleref{True}, but this method
can be overloaded in a subclass to support solver\sphinxhyphen{}specific logic
(e.g.  to confirm that a solver license is available).
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver can be executed.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_persistent() (PyomoSubmodelSolver\_PCCG method)@\spxentry{is\_persistent()}\spxextra{PyomoSubmodelSolver\_PCCG method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_PCCG.is_persistent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_persistent}}}{}{}
Returns True if the solver is persistent.

Persistent solvers maintain the model representation in memory,
which enables performance optimization when a problem is resolved
after changing initial conditions or tweaking model parameters.

The default is to return False, but this method can be overloaded
in a subclass to support solver\sphinxhyphen{}specific logic.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver is persistent.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{solve() (PyomoSubmodelSolver\_PCCG method)@\spxentry{solve()}\spxextra{PyomoSubmodelSolver\_PCCG method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_PCCG.solve}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{n}{model}}, \emph{\DUrole{o}{**}\DUrole{n}{options}}}{}
Executes the solver and loads the solution into the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{model}} \textendash{} The model that is being optimized.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{options}} \textendash{} Keyword options that are used to configure the solver.

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tee}} \textendash{} If True, then solver output is streamed to stdout. (default is False)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{load\_solutions}} \textendash{} If True, then the finale solution is loaded into the model. (default is True)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{linearize\_bigm}} \textendash{} The name of the big\sphinxhyphen{}M value used to linearize bilinear terms.  If this is not specified, then the solver will throw an error if bilinear terms exist in the model.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mip\_solver}} \textendash{} The MIP solver used by PCCG.  (default is cbc)

\end{itemize}

\item[{Returns}] \leavevmode
A summary of the optimization results.

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{reference/solverapi:pao.common.solver.Results}]{\sphinxcrossref{Results}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{valid\_license() (PyomoSubmodelSolver\_PCCG method)@\spxentry{valid\_license()}\spxextra{PyomoSubmodelSolver\_PCCG method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_PCCG.valid_license}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{valid\_license}}}{}{}
Returns a bool indicating if the solver has a valid license.

The default behavior is to always return \sphinxtitleref{True}, but this method
can be overloaded in a subclass to support solver\sphinxhyphen{}specific logic
(e.g.  to check the solver license).
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver license is valid.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{version() (PyomoSubmodelSolver\_PCCG method)@\spxentry{version()}\spxextra{PyomoSubmodelSolver\_PCCG method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_PCCG.version}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{version}}}{}{}
Returns a tuple that describes the solver version.

The return value is a tuple of strings.  A typical format is (major, minor, patch), but this
is not required. The default behavior is to return an empty tuple.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The solver version.

\item[{Return type}] \leavevmode
tuple

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{PyomoSubmodelSolver\_REG (class in pao.pyomo.solvers.mpr\_solvers)@\spxentry{PyomoSubmodelSolver\_REG}\spxextra{class in pao.pyomo.solvers.mpr\_solvers}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_REG}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{PyomoSubmodelSolver\_REG}}}{\emph{\DUrole{o}{**}\DUrole{n}{kwds}}}{}
PAO REG solver for Pyomo models: pao.pyomo.REG

This solver converts the Pyomo model to a LinearBilevelProblem and
calls the pao.mpr.REG solver.
\index{available() (PyomoSubmodelSolver\_REG method)@\spxentry{available()}\spxextra{PyomoSubmodelSolver\_REG method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_REG.available}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{available}}}{}{}
Returns a bool indicating if the solver can be executed.

The default behavior is to always return \sphinxtitleref{True}, but this method
can be overloaded in a subclass to support solver\sphinxhyphen{}specific logic
(e.g.  to confirm that a solver license is available).
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver can be executed.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_persistent() (PyomoSubmodelSolver\_REG method)@\spxentry{is\_persistent()}\spxextra{PyomoSubmodelSolver\_REG method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_REG.is_persistent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_persistent}}}{}{}
Returns True if the solver is persistent.

Persistent solvers maintain the model representation in memory,
which enables performance optimization when a problem is resolved
after changing initial conditions or tweaking model parameters.

The default is to return False, but this method can be overloaded
in a subclass to support solver\sphinxhyphen{}specific logic.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver is persistent.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{solve() (PyomoSubmodelSolver\_REG method)@\spxentry{solve()}\spxextra{PyomoSubmodelSolver\_REG method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_REG.solve}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{n}{model}}, \emph{\DUrole{o}{**}\DUrole{n}{options}}}{}
Executes the solver and loads the solution into the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{model}} \textendash{} The model that is being optimized.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{options}} \textendash{} Keyword options that are used to configure the solver.

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tee}} \textendash{} If True, then solver output is streamed to stdout. (default is False)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{load\_solutions}} \textendash{} If True, then the finale solution is loaded into the model. (default is True)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{linearize\_bigm}} \textendash{} The name of the big\sphinxhyphen{}M value used to linearize bilinear terms.  If this is not specified, then the solver will throw an error if bilinear terms exist in the model.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nlp\_solver}} \textendash{} The NLP solver used by REG.  (default is ipopt)

\end{itemize}

\item[{Returns}] \leavevmode
A summary of the optimization results.

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{reference/solverapi:pao.common.solver.Results}]{\sphinxcrossref{Results}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{valid\_license() (PyomoSubmodelSolver\_REG method)@\spxentry{valid\_license()}\spxextra{PyomoSubmodelSolver\_REG method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_REG.valid_license}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{valid\_license}}}{}{}
Returns a bool indicating if the solver has a valid license.

The default behavior is to always return \sphinxtitleref{True}, but this method
can be overloaded in a subclass to support solver\sphinxhyphen{}specific logic
(e.g.  to check the solver license).
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver license is valid.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{version() (PyomoSubmodelSolver\_REG method)@\spxentry{version()}\spxextra{PyomoSubmodelSolver\_REG method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/pyomo:pao.pyomo.solvers.mpr_solvers.PyomoSubmodelSolver_REG.version}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{version}}}{}{}
Returns a tuple that describes the solver version.

The return value is a tuple of strings.  A typical format is (major, minor, patch), but this
is not required. The default behavior is to return an empty tuple.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The solver version.

\item[{Return type}] \leavevmode
tuple

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{Compact Models}
\label{\detokenize{reference/mpr:compact-models}}\label{\detokenize{reference/mpr::doc}}

\paragraph{LinearMultilevelProblem Representation}
\label{\detokenize{reference/mpr:linearmultilevelproblem-representation}}\index{LinearMultilevelProblem (class in pao.mpr.repn)@\spxentry{LinearMultilevelProblem}\spxextra{class in pao.mpr.repn}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.repn.LinearMultilevelProblem}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{LinearMultilevelProblem}}}{\emph{\DUrole{n}{name}\DUrole{o}{=}\DUrole{default_value}{None}}}{}~
\begin{sphinxVerbatim}[commandchars=\\\{\}]
For bilevel problems, let:

  U   = LinearMultilevelProblem.U
  L   = U.L
  x   = [U.x, L.x]\PYGZsq{}       \PYGZsh{} dense column vector
  U.c = [U.c[U], U.c[L]]\PYGZsq{} \PYGZsh{} dense column vector
  L.c = [L.c[U], L.c[L]]\PYGZsq{} \PYGZsh{} dense column vector
  U.A = [U.A[U], U.A[L]]  \PYGZsh{} sparse matrix
  L.A = [L.A[U], L.A[L]]  \PYGZsh{} sparse matrix

Then we have:

  min\PYGZus{}\PYGZob{}U.x\PYGZcb{}   U.c\PYGZsq{} * x + U.d
  s.t.        U.A  * x       \PYGZlt{}= U.b                  \PYGZsh{} Or ==

          where L.x satisifies

              min\PYGZus{}\PYGZob{}L.x\PYGZcb{}   L.c\PYGZsq{} * x + L.d
              s.t.        L.A  * x       \PYGZlt{}= L.b      \PYGZsh{} Or ==
\end{sphinxVerbatim}

\end{fulllineitems}

\index{QuadraticMultilevelProblem (class in pao.mpr.repn)@\spxentry{QuadraticMultilevelProblem}\spxextra{class in pao.mpr.repn}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.repn.QuadraticMultilevelProblem}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{QuadraticMultilevelProblem}}}{\emph{\DUrole{n}{name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{bilinear}\DUrole{o}{=}\DUrole{default_value}{False}}}{}~
\begin{sphinxVerbatim}[commandchars=\\\{\}]
For bilevel problems, let:

  U   = QuadraticMultilevelProblem.U
  L   = U.L
  x   = [U.x, L.x]\PYGZsq{}           \PYGZsh{} dense column vector
  U.c = [U.c[U], U.c[L]]\PYGZsq{}     \PYGZsh{} dense column vector
  U.P = [U.P[U,U], U.P[U,L]]  \PYGZsh{} sparse matrix
        [0,        U.P[L,L]]
  U.A = [U.A[U], U.A[L]]      \PYGZsh{} sparse matrix
  U.Q = [U.Q[U,U], U.Q[U,L]]  \PYGZsh{} sparse matrix
        [0,        U.Q[L,L]]
  L.c = [L.c[U], L.c[L]]\PYGZsq{}     \PYGZsh{} dense column vector
  L.P = [L.P[U,U], L.P[U,L]]  \PYGZsh{} sparse matrix
        [0,        L.P[L,L]]
  L.A = [L.A[U], L.A[L]]      \PYGZsh{} sparse matrix
  L.Q = [L.Q[U,U], L.Q[U,L]]  \PYGZsh{} sparse matrix
        [0,        L.Q[L,L]]

Then we have:

  min\PYGZus{}\PYGZob{}U.x\PYGZcb{}   U.c\PYGZsq{} * x + x\PYGZsq{} * U.P * x + U.d
  s.t.        U.A  * x + x\PYGZsq{} * U.Q * x       \PYGZlt{}= U.b                 \PYGZsh{} Or ==

          where L.x satisifies

              min\PYGZus{}\PYGZob{}L.x\PYGZcb{}   L.c\PYGZsq{} * x + x\PYGZsq{} * L.P * x + L.d
              s.t.        L.A  * x + x\PYGZsq{} * L.Q * x       \PYGZlt{}= L.b     \PYGZsh{} Or ==
\end{sphinxVerbatim}

\end{fulllineitems}



\paragraph{Model Transformations}
\label{\detokenize{reference/mpr:model-transformations}}\index{convert\_to\_standard\_form() (in module pao.mpr.convert\_repn)@\spxentry{convert\_to\_standard\_form()}\spxextra{in module pao.mpr.convert\_repn}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.convert_repn.convert_to_standard_form}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{convert\_to\_standard\_form}}}{\emph{\DUrole{n}{M}}, \emph{\DUrole{n}{inequalities}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Normalize the LinearMultilevelProblem into a standard form.

This function copies the multilevel problem, \sphinxstylestrong{M}, and transforms
the problem such that
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Each real variable x is nonnegative (x \textgreater{}= 0)

\item {} 
Constraints have the specified form (e.g. all equalities or all inequalities)

\item {} 
Each level is a minimization problem

\end{enumerate}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{M}} ({\hyperref[\detokenize{reference/mpr:pao.mpr.repn.LinearMultilevelProblem}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{LinearMultilevelProblem}}}}}) \textendash{} The model that is being normalized

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inequalities}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{Default: False}}) \textendash{} If this is True, then the normalized form has inequality constraints.  Otherwise, the normalized
form has equality constraints.

\end{itemize}

\item[{Returns}] \leavevmode
A normalized version of the input model

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{reference/mpr:pao.mpr.repn.LinearMultilevelProblem}]{\sphinxcrossref{LinearMultilevelProblem}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{linearize\_bilinear\_terms() (in module pao.mpr.convert\_repn)@\spxentry{linearize\_bilinear\_terms()}\spxextra{in module pao.mpr.convert\_repn}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.convert_repn.linearize_bilinear_terms}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{linearize\_bilinear\_terms}}}{\emph{\DUrole{n}{M}}, \emph{\DUrole{n}{bigM}}}{}
Generate a linear multilevel problem from a quadratic multilevel
problem by linearizing bilinear terms.

This function copies the linear terms in the multilevel problem,
\sphinxstylestrong{M}, and replaces bilinear terms with a new variable.  This
transformation only applies when at least one of the variables in
each bilinear term is binary or integer.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{M}} ({\hyperref[\detokenize{reference/mpr:pao.mpr.repn.QuadraticMultilevelProblem}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{QuadraticMultilevelProblem}}}}}) \textendash{} The model that is being linearized

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bigM}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The big\sphinxhyphen{}M value used to linearize nonlinear terms

\end{itemize}

\item[{Returns}] \leavevmode
A linearized version of the input model

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{reference/mpr:pao.mpr.repn.LinearMultilevelProblem}]{\sphinxcrossref{LinearMultilevelProblem}}}

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{PAO Solvers}
\label{\detokenize{reference/mpr:pao-solvers}}\index{LinearMultilevelSolver\_FA (class in pao.mpr.solvers.fa)@\spxentry{LinearMultilevelSolver\_FA}\spxextra{class in pao.mpr.solvers.fa}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.fa.LinearMultilevelSolver_FA}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{LinearMultilevelSolver\_FA}}}{\emph{\DUrole{o}{**}\DUrole{n}{kwds}}}{}
PAO FA solver for linear MPRs: pao.mpr.FA

This solver replaces lower\sphinxhyphen{}level problems using the KKT conditions and
calls a MIP solver to solve the reformulated problem.
\index{available() (LinearMultilevelSolver\_FA method)@\spxentry{available()}\spxextra{LinearMultilevelSolver\_FA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.fa.LinearMultilevelSolver_FA.available}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{available}}}{}{}
Returns a bool indicating if the solver can be executed.

The default behavior is to always return \sphinxtitleref{True}, but this method
can be overloaded in a subclass to support solver\sphinxhyphen{}specific logic
(e.g.  to confirm that a solver license is available).
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver can be executed.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_persistent() (LinearMultilevelSolver\_FA method)@\spxentry{is\_persistent()}\spxextra{LinearMultilevelSolver\_FA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.fa.LinearMultilevelSolver_FA.is_persistent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_persistent}}}{}{}
Returns True if the solver is persistent.

Persistent solvers maintain the model representation in memory,
which enables performance optimization when a problem is resolved
after changing initial conditions or tweaking model parameters.

The default is to return False, but this method can be overloaded
in a subclass to support solver\sphinxhyphen{}specific logic.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver is persistent.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{solve() (LinearMultilevelSolver\_FA method)@\spxentry{solve()}\spxextra{LinearMultilevelSolver\_FA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.fa.LinearMultilevelSolver_FA.solve}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{n}{model}}, \emph{\DUrole{o}{**}\DUrole{n}{options}}}{}
Executes the solver and loads the solution into the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{model}} \textendash{} The model that is being optimized.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{options}} \textendash{} Keyword options that are used to configure the solver.

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tee}} \textendash{} If True, then solver output is streamed to stdout. (default is False)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{load\_solutions}} \textendash{} If True, then the finale solution is loaded into the model. (default is True)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mip\_solver}} \textendash{} The MIP solver used by FA.  (default is glpk)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bigm}} \textendash{} The big\sphinxhyphen{}M value used to enforce complementarity conditions.  (default is 1e5)

\end{itemize}

\item[{Returns}] \leavevmode
A summary of the optimization results.

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{reference/solverapi:pao.common.solver.Results}]{\sphinxcrossref{Results}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{valid\_license() (LinearMultilevelSolver\_FA method)@\spxentry{valid\_license()}\spxextra{LinearMultilevelSolver\_FA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.fa.LinearMultilevelSolver_FA.valid_license}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{valid\_license}}}{}{}
Returns a bool indicating if the solver has a valid license.

The default behavior is to always return \sphinxtitleref{True}, but this method
can be overloaded in a subclass to support solver\sphinxhyphen{}specific logic
(e.g.  to check the solver license).
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver license is valid.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{version() (LinearMultilevelSolver\_FA method)@\spxentry{version()}\spxextra{LinearMultilevelSolver\_FA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.fa.LinearMultilevelSolver_FA.version}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{version}}}{}{}
Returns a tuple that describes the solver version.

The return value is a tuple of strings.  A typical format is (major, minor, patch), but this
is not required. The default behavior is to return an empty tuple.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The solver version.

\item[{Return type}] \leavevmode
tuple

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{LinearMultilevelSolver\_MIBS (class in pao.mpr.solvers.mibs)@\spxentry{LinearMultilevelSolver\_MIBS}\spxextra{class in pao.mpr.solvers.mibs}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.mibs.LinearMultilevelSolver_MIBS}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{LinearMultilevelSolver\_MIBS}}}{\emph{\DUrole{o}{**}\DUrole{n}{kwds}}}{}
PAO MibS solver for linear MPRs: pao.mpr.MIBS
\index{available() (LinearMultilevelSolver\_MIBS method)@\spxentry{available()}\spxextra{LinearMultilevelSolver\_MIBS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.mibs.LinearMultilevelSolver_MIBS.available}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{available}}}{}{}
Returns a bool indicating if the solver can be executed.

The default behavior is to always return \sphinxtitleref{True}, but this method
can be overloaded in a subclass to support solver\sphinxhyphen{}specific logic
(e.g.  to confirm that a solver license is available).
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver can be executed.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_mibs\_model() (LinearMultilevelSolver\_MIBS method)@\spxentry{create\_mibs\_model()}\spxextra{LinearMultilevelSolver\_MIBS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.mibs.LinearMultilevelSolver_MIBS.create_mibs_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_mibs\_model}}}{\emph{\DUrole{n}{repn}}, \emph{\DUrole{n}{mps\_filename}}, \emph{\DUrole{n}{aux\_filename}}}{}
TODO \sphinxhyphen{} Document this transformation

\end{fulllineitems}

\index{is\_persistent() (LinearMultilevelSolver\_MIBS method)@\spxentry{is\_persistent()}\spxextra{LinearMultilevelSolver\_MIBS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.mibs.LinearMultilevelSolver_MIBS.is_persistent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_persistent}}}{}{}
Returns True if the solver is persistent.

Persistent solvers maintain the model representation in memory,
which enables performance optimization when a problem is resolved
after changing initial conditions or tweaking model parameters.

The default is to return False, but this method can be overloaded
in a subclass to support solver\sphinxhyphen{}specific logic.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver is persistent.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{solve() (LinearMultilevelSolver\_MIBS method)@\spxentry{solve()}\spxextra{LinearMultilevelSolver\_MIBS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.mibs.LinearMultilevelSolver_MIBS.solve}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{n}{model}}, \emph{\DUrole{o}{**}\DUrole{n}{options}}}{}
Executes the solver and loads the solution into the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{model}} \textendash{} The model that is being optimized.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{options}} \textendash{} Keyword options that are used to configure the solver.

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tee}} \textendash{} If True, then solver output is streamed to stdout. (default is False)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{load\_solutions}} \textendash{} If True, then the finale solution is loaded into the model. (default is True)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{executable}} \textendash{} The executable used for MibS.  (default is mibs)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{param\_file}} \textendash{} The parameter file used to configure MibS.  (default is None)

\end{itemize}

\item[{Returns}] \leavevmode
A summary of the optimization results.

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{reference/solverapi:pao.common.solver.Results}]{\sphinxcrossref{Results}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{valid\_license() (LinearMultilevelSolver\_MIBS method)@\spxentry{valid\_license()}\spxextra{LinearMultilevelSolver\_MIBS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.mibs.LinearMultilevelSolver_MIBS.valid_license}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{valid\_license}}}{}{}
Returns a bool indicating if the solver has a valid license.

The default behavior is to always return \sphinxtitleref{True}, but this method
can be overloaded in a subclass to support solver\sphinxhyphen{}specific logic
(e.g.  to check the solver license).
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver license is valid.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{version() (LinearMultilevelSolver\_MIBS method)@\spxentry{version()}\spxextra{LinearMultilevelSolver\_MIBS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.mibs.LinearMultilevelSolver_MIBS.version}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{version}}}{}{}
Returns a tuple that describes the solver version.

The return value is a tuple of strings.  A typical format is (major, minor, patch), but this
is not required. The default behavior is to return an empty tuple.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The solver version.

\item[{Return type}] \leavevmode
tuple

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{LinearMultilevelSolver\_PCCG (class in pao.mpr.solvers.pccg)@\spxentry{LinearMultilevelSolver\_PCCG}\spxextra{class in pao.mpr.solvers.pccg}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.pccg.LinearMultilevelSolver_PCCG}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{LinearMultilevelSolver\_PCCG}}}{\emph{\DUrole{o}{**}\DUrole{n}{kwds}}}{}
PAO PCCG solver for linear MPRs: pao.mpr.PCCG

This solver iteratively adds constraints to tighten a relaxation of the lower\sphinxhyphen{}level problem.
\index{available() (LinearMultilevelSolver\_PCCG method)@\spxentry{available()}\spxextra{LinearMultilevelSolver\_PCCG method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.pccg.LinearMultilevelSolver_PCCG.available}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{available}}}{}{}
Returns a bool indicating if the solver can be executed.

The default behavior is to always return \sphinxtitleref{True}, but this method
can be overloaded in a subclass to support solver\sphinxhyphen{}specific logic
(e.g.  to confirm that a solver license is available).
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver can be executed.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_persistent() (LinearMultilevelSolver\_PCCG method)@\spxentry{is\_persistent()}\spxextra{LinearMultilevelSolver\_PCCG method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.pccg.LinearMultilevelSolver_PCCG.is_persistent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_persistent}}}{}{}
Returns True if the solver is persistent.

Persistent solvers maintain the model representation in memory,
which enables performance optimization when a problem is resolved
after changing initial conditions or tweaking model parameters.

The default is to return False, but this method can be overloaded
in a subclass to support solver\sphinxhyphen{}specific logic.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver is persistent.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{solve() (LinearMultilevelSolver\_PCCG method)@\spxentry{solve()}\spxextra{LinearMultilevelSolver\_PCCG method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.pccg.LinearMultilevelSolver_PCCG.solve}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{n}{mpr}}, \emph{\DUrole{n}{options}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{config\_options}}}{}
Executes the solver and loads the solution into the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{model}} \textendash{} The model that is being optimized.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{options}} \textendash{} Keyword options that are used to configure the solver.

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tee}} \textendash{} If True, then solver output is streamed to stdout. (default is False)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{load\_solutions}} \textendash{} If True, then the finale solution is loaded into the model. (default is True)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mip\_solver}} \textendash{} The MIP solver used by PCCG.  (default is cbc)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bigm}} \textendash{} The big\sphinxhyphen{}M value used to enforce complementarity conditions.       (default is 1e6)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{epsilon}} \textendash{} Parameter used in disjunction approximation. (default is 1e\sphinxhyphen{}4)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{atol}} \textendash{} Convergence tolerance for |UB\sphinxhyphen{}LB|. (default is 1e\sphinxhyphen{}8)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rtol}} \textendash{} Convergence tolerance for |UB\sphinxhyphen{}LB|. (default is 1e\sphinxhyphen{}8)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{maxit}} \textendash{} Maximum number of iterations. (default is None)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{quiet}} \textendash{} If False, then enable verbose solver output. (default is True)

\end{itemize}

\item[{Returns}] \leavevmode
A summary of the optimization results.

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{reference/solverapi:pao.common.solver.Results}]{\sphinxcrossref{Results}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{valid\_license() (LinearMultilevelSolver\_PCCG method)@\spxentry{valid\_license()}\spxextra{LinearMultilevelSolver\_PCCG method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.pccg.LinearMultilevelSolver_PCCG.valid_license}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{valid\_license}}}{}{}
Returns a bool indicating if the solver has a valid license.

The default behavior is to always return \sphinxtitleref{True}, but this method
can be overloaded in a subclass to support solver\sphinxhyphen{}specific logic
(e.g.  to check the solver license).
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver license is valid.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{version() (LinearMultilevelSolver\_PCCG method)@\spxentry{version()}\spxextra{LinearMultilevelSolver\_PCCG method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.pccg.LinearMultilevelSolver_PCCG.version}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{version}}}{}{}
Returns a tuple that describes the solver version.

The return value is a tuple of strings.  A typical format is (major, minor, patch), but this
is not required. The default behavior is to return an empty tuple.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The solver version.

\item[{Return type}] \leavevmode
tuple

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{LinearMultilevelSolver\_REG (class in pao.mpr.solvers.reg)@\spxentry{LinearMultilevelSolver\_REG}\spxextra{class in pao.mpr.solvers.reg}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.reg.LinearMultilevelSolver_REG}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{LinearMultilevelSolver\_REG}}}{\emph{\DUrole{o}{**}\DUrole{n}{kwds}}}{}
PAO REG solver for linear MPRs: pao.mpr.REG

This solver replaces lower\sphinxhyphen{}level problems using the KKT conditions and
calls a NLP solver to solve the reformulated problem.
\index{available() (LinearMultilevelSolver\_REG method)@\spxentry{available()}\spxextra{LinearMultilevelSolver\_REG method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.reg.LinearMultilevelSolver_REG.available}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{available}}}{}{}
Returns a bool indicating if the solver can be executed.

The default behavior is to always return \sphinxtitleref{True}, but this method
can be overloaded in a subclass to support solver\sphinxhyphen{}specific logic
(e.g.  to confirm that a solver license is available).
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver can be executed.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_persistent() (LinearMultilevelSolver\_REG method)@\spxentry{is\_persistent()}\spxextra{LinearMultilevelSolver\_REG method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.reg.LinearMultilevelSolver_REG.is_persistent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_persistent}}}{}{}
Returns True if the solver is persistent.

Persistent solvers maintain the model representation in memory,
which enables performance optimization when a problem is resolved
after changing initial conditions or tweaking model parameters.

The default is to return False, but this method can be overloaded
in a subclass to support solver\sphinxhyphen{}specific logic.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver is persistent.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{solve() (LinearMultilevelSolver\_REG method)@\spxentry{solve()}\spxextra{LinearMultilevelSolver\_REG method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.reg.LinearMultilevelSolver_REG.solve}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{n}{model}}, \emph{\DUrole{o}{**}\DUrole{n}{options}}}{}
Executes the solver and loads the solution into the model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{model}} \textendash{} The model that is being optimized.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{options}} \textendash{} Keyword options that are used to configure the solver.

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tee}} \textendash{} If True, then solver output is streamed to stdout. (default is False)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{load\_solutions}} \textendash{} If True, then the finale solution is loaded into the model. (default is True)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nlp\_solver}} \textendash{} The NLP solver used by REG.  (default is ipopt)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rho}} \textendash{} The tolerance for constraints that enforce complementarity conditions.  (default is 1e\sphinxhyphen{}7)

\end{itemize}

\item[{Returns}] \leavevmode
A summary of the optimization results.

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{reference/solverapi:pao.common.solver.Results}]{\sphinxcrossref{Results}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{valid\_license() (LinearMultilevelSolver\_REG method)@\spxentry{valid\_license()}\spxextra{LinearMultilevelSolver\_REG method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.reg.LinearMultilevelSolver_REG.valid_license}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{valid\_license}}}{}{}
Returns a bool indicating if the solver has a valid license.

The default behavior is to always return \sphinxtitleref{True}, but this method
can be overloaded in a subclass to support solver\sphinxhyphen{}specific logic
(e.g.  to check the solver license).
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This method returns True if the solver license is valid.

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{version() (LinearMultilevelSolver\_REG method)@\spxentry{version()}\spxextra{LinearMultilevelSolver\_REG method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/mpr:pao.mpr.solvers.reg.LinearMultilevelSolver_REG.version}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{version}}}{}{}
Returns a tuple that describes the solver version.

The return value is a tuple of strings.  A typical format is (major, minor, patch), but this
is not required. The default behavior is to return an empty tuple.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The solver version.

\item[{Return type}] \leavevmode
tuple

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\begin{sphinxadmonition}{warning}{Warning:}
The logic in \sphinxcode{\sphinxupquote{pao.duality}} is currently disabled.  There are known errors in this code
that will be resolved by re\sphinxhyphen{}implementing it using the logic in \sphinxcode{\sphinxupquote{pao.mpr}}.
\end{sphinxadmonition}


\if 0

\section{Bibliography}
\label{\detokenize{bibliography:bibliography}}\label{\detokenize{bibliography::doc}}

\section{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\subsection{PAO Resources}
\label{\detokenize{index:pao-resources}}
PAO development is hosted at GitHub:
\begin{itemize}
\item {} 
\sphinxurl{https://github.com/or-fusion/pao}

\end{itemize}

The OR\sphinxhyphen{}Fusion GitHub organization is used to coordinate installation of
PAO with other OR\sphinxhyphen{}related capabilities:
\begin{itemize}
\item {} 
\sphinxurl{https://github.com/or-fusion}

\end{itemize}

Ask a question on StackOverflow:
\begin{itemize}
\item {} 
\sphinxurl{https://stackoverflow.com/questions/ask?tags=pyomo}

\end{itemize}
\fi


\begin{sphinxthebibliography}{FortunyM}

\bibitem[1]{anadalingam}
G. Anandalingam, A mathematical programming model of decentralized multi\sphinxhyphen{}level systems.
J. Oper.Res. Soc.39(11), 1021\textendash{}1033 (1988)

\bibitem[2]{bard98}
J. F. Bard, Practical bilevel optimization: Algorithms and
applications. Kluwer Academic Publishers, 1998.

\bibitem[3]{fortunymccarl}
J. Fortuny\sphinxhyphen{}Amat and B. McCarl, A representation and economic interpretation of a two\sphinxhyphen{}level programming problem,
The Journal of the Operations Research Society. 32(9), 783\sphinxhyphen{}792, 1981.

\bibitem[4]{neos}
\sphinxurl{https://neos-server.org/neos/}

\bibitem[5]{pyomobookii}
W. E. Hart, C. D. Laird,
J.\sphinxhyphen{}P. Watson, D. L. Woodruff, G. A. Hackebeil, B. L. Nicholson,
J. D. Siirola. Pyomo \sphinxhyphen{} Optimization Modeling in Python,
2nd Edition.  Springer Optimization and Its
Applications, Vol 67.  Springer, 2017.

\bibitem[6]{pyomoweb}
\sphinxurl{http://www.pyomo.org/}

\bibitem[7]{pyomogithub}
\sphinxurl{https://github.com/Pyomo/pyomo}
\end{sphinxthebibliography}



\if 0
\renewcommand{\indexname}{Index}
\printindex
\end{document}
\fi
